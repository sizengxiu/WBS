'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _$f = _interopDefault(require('lodash'));
var d3Force = _interopDefault(require('d3-force'));
var dagre = _interopDefault(require('dagre'));

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = o[Symbol.iterator]();
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

var EventEmit3 = require('eventemitter3');

var Canvas = /*#__PURE__*/function (_EventEmit) {
  _inherits(Canvas, _EventEmit);

  var _super = _createSuper(Canvas);

  function Canvas() {
    _classCallCheck(this, Canvas);

    // root             根节点
    // layout           布局支持
    // zoomable         是否可放大缩小
    // moveable         是否可移动
    // draggable        是否可拖动节点
    // linkable         是否可连接线条
    // disLinkable      是否可取消连线
    // theme            主题配置
    // global           公共配置
    return _super.call(this);
  } // 渲染节点


  _createClass(Canvas, [{
    key: "draw",
    value: function draw() {} // 获取节点

  }, {
    key: "getNode",
    value: function getNode() {} // 获取线条

  }, {
    key: "getEdge",
    value: function getEdge() {} // 获取节点组

  }, {
    key: "getGroup",
    value: function getGroup() {} // 添加节点

  }, {
    key: "addNode",
    value: function addNode() {} // 批量添加节点

  }, {
    key: "addNodes",
    value: function addNodes() {} // 添加线条

  }, {
    key: "addEdge",
    value: function addEdge() {} // 批量添加线条

  }, {
    key: "addEdges",
    value: function addEdges() {} // 批量添加节点组

  }, {
    key: "addGroups",
    value: function addGroups() {} // 删除节点

  }, {
    key: "removeNode",
    value: function removeNode() {} // 批量删除节点

  }, {
    key: "removeNodes",
    value: function removeNodes() {} // 删除线条

  }, {
    key: "removeEdge",
    value: function removeEdge() {} // 批量删除线条

  }, {
    key: "removeEdges",
    value: function removeEdges() {} // 删除节点组

  }, {
    key: "removeGroup",
    value: function removeGroup() {} // 获取相邻的线条

  }, {
    key: "getNeighborEdges",
    value: function getNeighborEdges() {} // 获取相邻的节点

  }, {
    key: "getNeighborNodes",
    value: function getNeighborNodes() {} // 获取无环血缘图

  }, {
    key: "getNeighborNodesAndEdgesByLevel",
    value: function getNeighborNodesAndEdgesByLevel() {}
  }, {
    key: "getAdjcentTable",
    value: function getAdjcentTable() {} // 需要改为内部方法
    // 获取缩放值

  }, {
    key: "getZoom",
    value: function getZoom() {} // 动态设置可缩放

  }, {
    key: "setZoomable",
    value: function setZoomable() {} // 动态设置缩放值

  }, {
    key: "zoom",
    value: function zoom() {} // 获取偏移值

  }, {
    key: "getOffset",
    value: function getOffset() {} // 动态设置可移动

  }, {
    key: "setMoveable",
    value: function setMoveable() {} // 动态设置移动

  }, {
    key: "move",
    value: function move() {} // 获取中心点

  }, {
    key: "getOrigin",
    value: function getOrigin() {} // 动态设置中心点

  }, {
    key: "setOrigin",
    value: function setOrigin() {} // 获取数据结构

  }, {
    key: "getDataMap",
    value: function getDataMap() {} // 设置网格模式

  }, {
    key: "setGirdMode",
    value: function setGirdMode() {} // 设置网格线条

  }, {
    key: "setGuideLine",
    value: function setGuideLine() {} // 设置辅助线

  }, {
    key: "justifyCoordinate",
    value: function justifyCoordinate() {} // 设置框选模式

  }, {
    key: "setSelectMode",
    value: function setSelectMode() {} // 设置某些联合值，即框选的元素

  }, {
    key: "getUnion",
    value: function getUnion() {} // 设置所有联合值，即框选的元素

  }, {
    key: "getAllUnion",
    value: function getAllUnion() {} // 添加联合值

  }, {
    key: "add2Union",
    value: function add2Union() {} // 删除某些联合值

  }, {
    key: "removeUnion",
    value: function removeUnion() {} // 删除所有联合值

  }, {
    key: "removeAllUnion",
    value: function removeAllUnion() {} // 聚焦单个节点（看看需要合并不）

  }, {
    key: "focusNodeWithAnimate",
    value: function focusNodeWithAnimate() {} // 聚焦某些节点

  }, {
    key: "focusNodesWithAnimate",
    value: function focusNodesWithAnimate() {} // 画布坐标转换为终端坐标

  }, {
    key: "canvas2terminal",
    value: function canvas2terminal() {} // 终端坐标转换为画布坐标

  }, {
    key: "terminal2canvas",
    value: function terminal2canvas() {} // 保存为图片

  }, {
    key: "save2img",
    value: function save2img() {} // ********* 需要优化的api ********* 
    // 更新画布的大小 

  }, {
    key: "updateRootResize",
    value: function updateRootResize() {} // ********* 需要新增的api ********* 
    // 单击的回调

  }, {
    key: "click",
    value: function click() {} // 双击的回调

  }, {
    key: "doubleClick",
    value: function doubleClick() {} // 右键的回调

  }, {
    key: "onContextmenu",
    value: function onContextmenu() {} // 集成menu
    // 生成/关闭缩略图

  }]);

  return Canvas;
}(EventEmit3);

var EventEmit3$1 = require('eventemitter3');

var Node$1 = /*#__PURE__*/function (_EventEmit) {
  _inherits(Node, _EventEmit);

  var _super = _createSuper(Node);

  function Node() {
    _classCallCheck(this, Node);

    // id        节点唯一标志
    // top       坐标y
    // left      坐标x
    // group     存在于哪个节点组上
    // dom       节点的dom元素
    // draggable 该节点是否能拖动标志，可覆盖全局的
    // options   数据的透传
    // _on       节点发送事件
    // _emit     节点发送事件
    // _global   全局的配置
    // 需要优化的
    // scope           scope相同可拉进group里面
    // endpoints       endpoint对象
    // _endpointsData  真实的endpoint数据
    // _isMoving       标识是否在移动做，兼容冒泡
    return _super.call(this);
  } // 渲染节点


  _createClass(Node, [{
    key: "draw",
    value: function draw() {} // 获取锚点

  }, {
    key: "getEndpoint",
    value: function getEndpoint() {} // 添加锚点

  }, {
    key: "addEndpoint",
    value: function addEndpoint() {} // 删除锚点

  }, {
    key: "removeEndpoint",
    value: function removeEndpoint() {} // 移动节点

  }, {
    key: "moveTo",
    value: function moveTo() {} // 获取宽度

  }, {
    key: "getWidth",
    value: function getWidth() {} // 获取高度

  }, {
    key: "getHeight",
    value: function getHeight() {} // 设置该节点是否能拖动，能覆盖全局

  }, {
    key: "setDraggable",
    value: function setDraggable() {} // remove的方法

  }, {
    key: "remove",
    value: function remove() {} // 销毁的方法

  }, {
    key: "destroy",
    value: function destroy() {} // ********* 需要新增的api ********* 
    // focus回调

  }, {
    key: "focus",
    value: function focus() {} // unFocus回调

  }, {
    key: "unFocus",
    value: function unFocus() {} // 单击的回调

  }, {
    key: "click",
    value: function click() {} // 双击的回调

  }, {
    key: "doubleClick",
    value: function doubleClick() {} // 右键的回调

  }, {
    key: "onContextmenu",
    value: function onContextmenu() {} // hover的回调

  }, {
    key: "hover",
    value: function hover() {}
  }]);

  return Node;
}(EventEmit3$1);

var EventEmit3$2 = require('eventemitter3');

var Endpoint = /*#__PURE__*/function (_EventEmit) {
  _inherits(Endpoint, _EventEmit);

  var _super = _createSuper(Endpoint);

  function Endpoint() {
    _classCallCheck(this, Endpoint);

    return _super.call(this);
  }

  return Endpoint;
}(EventEmit3$2);

var $ = require('jquery');

var _$1 = require('lodash');

var BaseEndpoint = /*#__PURE__*/function (_Endpoint) {
  _inherits(BaseEndpoint, _Endpoint);

  var _super = _createSuper(BaseEndpoint);

  function BaseEndpoint(opts) {
    var _this;

    _classCallCheck(this, BaseEndpoint);

    _this = _super.call(this, opts);
    _this.id = opts.id;
    _this.options = opts;
    _this.orientation = opts.orientation;
    _this.pos = opts.pos;
    _this.type = opts.type;
    _this.nodeType = _$1.get(opts, 'nodeType', 'node');
    _this.nodeId = _$1.get(opts, '_node.id');
    _this.root = opts.root;
    _this.scope = opts.scope;
    _this.expandArea = opts.expandArea;
    _this.limitNum = opts.limitNum;
    _this.options = opts; // 鸭子辨识手动判断类型

    _this.__type = 'endpoint'; // 假如锚点在节点上则有值

    _this._node = opts._node;
    _this._global = opts._global;
    _this._on = opts._on;
    _this._emit = opts._emit; // 相对坐标

    _this._top = 0;
    _this._left = 0; // 相对于画布的绝对坐标

    _this._posTop = 0;
    _this._posLeft = 0;
    _this._width = 0;
    _this._height = 0; // 拉线时候可连接的标志

    _this._linkable = false;
    _this._coordinateService = null;
    _this.dom = null; // 判断自定义锚点

    _this._isInitedDom = false;

    if (opts.dom) {
      _this.dom = opts.dom;
      _this._isInitedDom = true;
    }

    return _this;
  }

  _createClass(BaseEndpoint, [{
    key: "_init",
    value: function _init(obj) {
      this._coordinateService = obj._coordinateService;

      if (obj.nodeType) {
        this.nodeType = obj.nodeType;
      } // 计算锚点起始值


      if (!this._isInitedDom) {
        this.dom = this.draw({
          id: this.id,
          orientation: this.orientation,
          pos: this.pos,
          dom: this.dom,
          root: this.root,
          type: this.type,
          options: this.options
        });
      } else {
        // 计算width,height,left,top
        this._width = $(this.dom).width();
        this._height = $(this.dom).height();
        this._left = this._coordinateService._terminal2canvas('x', $(this.dom).offset().left);
        this._top = this._coordinateService._terminal2canvas('y', $(this.dom).offset().top);
        this._posTop = this._top;
        this._posLeft = this._left;
      }

      this.attachEvent();
    }
  }, {
    key: "draw",
    value: function draw(obj) {
      var _dom = obj.dom;

      if (!_dom) {
        _dom = $('<div class="butterflie-circle-endpoint"></div>').attr('id', this.id);
      } else {
        _dom = $(_dom);
      }

      return _dom[0];
    }
  }, {
    key: "updatePos",
    value: function updatePos() {
      var dom = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.dom;
      var orientation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.orientation;
      var pos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.pos;

      if (this._isInitedDom) {
        // 计算width,height,left,top
        this._width = $(this.dom).width();
        this._height = $(this.dom).height(); // 计算锚点起始值

        this._left = this._coordinateService._terminal2canvas('x', $(this.dom).offset().left);
        this._top = this._coordinateService._terminal2canvas('y', $(this.dom).offset().top);
        this._posLeft = this._left;
        this._posTop = this._top;
      } else {
        var _currentNode = this._node;

        var _currentDom = $(this._node.dom);

        var _currentNodeType = this.nodeType; // 分情况弄好方向和位置

        var nodeW = _currentDom.outerWidth();

        var nodeH = _currentDom.outerHeight();

        var targetDom = null;
        var targetDomW = 0;
        var targetDomH = 0;

        if (this.root) {
          targetDom = _currentDom.find(this.root);
          targetDomW = targetDom.width();
          targetDomH = targetDom.height();
        }

        this._width = $(dom).outerWidth();
        this._height = $(dom).outerHeight(); // 计算节点本身的偏移量

        var eOffsetX = this._width / 2;
        var eOffsetY = this._height / 2;
        var _offsetTop = 0;
        var _offsetLeft = 0;

        var _orientation = orientation || this.orientation || [0, -1];

        var _pos = pos || this.pos || [_orientation[0] === 0 ? 0.5 : 0, _orientation[1] === 0 ? 0.5 : 0];

        var result = [0, 0];
        var _ox = _orientation[0];
        var _oy = _orientation[1];
        var _px = _pos[0];
        var _py = _pos[1];

        if (_ox === 0) {
          result[0] = !this.root ? nodeW * _px - eOffsetX : targetDomW * _px - eOffsetX;
        } else if (_ox === -1) {
          result[0] = 0 - eOffsetX;
        } else if (_ox === 1) {
          result[0] = !this.root ? nodeW - eOffsetX : targetDomW - eOffsetX;
        }

        if (_oy === 0) {
          result[1] = !this.root ? nodeH * _py - eOffsetY : targetDomH * _py - eOffsetY;
        } else if (_oy === -1) {
          result[1] = 0 - eOffsetY;
        } else if (_oy === 1) {
          result[1] = !this.root ? nodeH - eOffsetY : targetDomH - eOffsetY;
        } // 计算绝对定位


        if (_currentNode && !this.root) {
          _offsetTop += _currentNode.top;
          _offsetLeft += _currentNode.left;
        } else if (_currentNode && this.root) {
          // 计算传入的dom距离跟节点
          var nodeDomOffsets = _currentDom.offset();

          var targetDomOffsets = targetDom.offset(); // 先计算目标节点和父节点得差值再加上父节点的offset

          _offsetTop += targetDomOffsets.top - nodeDomOffsets.top + _currentNode.top;
          _offsetLeft += targetDomOffsets.left - nodeDomOffsets.left + _currentNode.left;
        }

        this._top = result[1] + _offsetTop;
        this._left = result[0] + _offsetLeft;
        this._posTop = this._top;
        this._posLeft = this._left;

        if (_currentNodeType === 'node' && _currentNode._group) {
          this._posTop += _currentNode._group.top;
          this._posLeft += _currentNode._group.left;
        }

        $(dom).css('top', this._top).css('left', this._left);
        this.updated && this.updated();
      }
    }
  }, {
    key: "moveTo",
    value: function moveTo(x, y) {
      this._top = y;
      this._left = x;
      this._posTop = this._top;
      this._posLeft = this._left;

      if (!this._isInitedDom) {
        $(this.dom).css('top', y).css('left', x);

        if (_$1.get(this, '_node._group')) {
          this._posTop += this._node._group.top;
          this._posLeft += this._node._group.left;
        }
      }
    }
  }, {
    key: "linkable",
    value: function linkable() {
      $(this.dom).addClass('linkable');
    }
  }, {
    key: "unLinkable",
    value: function unLinkable() {
      $(this.dom).removeClass('linkable');
    }
  }, {
    key: "hoverLinkable",
    value: function hoverLinkable() {
      $(this.dom).addClass('hover');
    }
  }, {
    key: "unHoverLinkable",
    value: function unHoverLinkable() {
      $(this.dom).removeClass('hover');
    }
  }, {
    key: "attachEvent",
    value: function attachEvent() {
      var _this2 = this;

      $(this.dom).on('mousedown', function (e) {
        var LEFT_KEY = 0;

        if (e.button !== LEFT_KEY) {
          return;
        }

        e.preventDefault();
        e.stopPropagation();

        _this2.emit('InnerEvents', {
          type: 'endpoint:drag',
          data: _this2
        });
      });
    }
  }, {
    key: "emit",
    value: function emit(type, data) {
      _get(_getPrototypeOf(BaseEndpoint.prototype), "emit", this).call(this, type, data);

      this._emit(type, data);
    }
  }, {
    key: "destroy",
    value: function destroy(isNotEvent) {
      if (!isNotEvent) {
        $(this.dom).off();
        $(this.dom).remove();
        this.removeAllListeners();
      } else {
        $(this.dom).detach();
      }
    }
  }]);

  return BaseEndpoint;
}(Endpoint);

var $$1 = require('jquery');

var _$2 = require('lodash');

var BaseNode = /*#__PURE__*/function (_Node) {
  _inherits(BaseNode, _Node);

  var _super = _createSuper(BaseNode);

  function BaseNode(opts) {
    var _this;

    _classCallCheck(this, BaseNode);

    _this = _super.call(this, opts);
    _this.id = opts.id;
    _this.scope = opts.scope;
    _this.group = opts.group;
    _this.top = opts.top || 0;
    _this.left = opts.left || 0;
    _this.dom = opts.dom || null;
    _this.draggable = opts.draggable;
    _this.options = opts; // 鸭子辨识手动判断类型

    _this.__type = 'node';
    _this._on = opts._on;
    _this._emit = opts._emit;
    _this._global = opts._global; // endpoint 这部分需要考虑

    _this.endpoints = [];
    _this._endpointsData = opts.endpoints;
    _this._endpointLimitNum = opts._endpointLimitNum; // 标识是否在移动做，兼容冒泡

    _this._isMoving = false;
    return _this;
  }

  _createClass(BaseNode, [{
    key: "draw",
    value: function draw(obj) {
      var _dom = obj.dom;

      if (!_dom) {
        _dom = $$1('<div></div>').attr('class', 'node').attr('id', obj.id);
      }

      var node = $$1(_dom);

      if (obj.top !== undefined) {
        node.css('top', "".concat(obj.top, "px"));
      }

      if (obj.left !== undefined) {
        node.css('left', "".concat(obj.left, "px"));
      }

      this.updated && this.updated();
      return node[0];
    }
  }, {
    key: "focus",
    value: function focus() {}
  }, {
    key: "unFocus",
    value: function unFocus() {}
  }, {
    key: "addEndpoint",
    value: function addEndpoint(obj, isInited) {
      if (isInited) {
        this.emit('InnerEvents', {
          type: 'node:addEndpoint',
          data: obj,
          isInited: isInited
        });
        return obj;
      } // 这部分可能还需要想一下


      var EndpointClass = obj.Class || BaseEndpoint;
      var endpoint = new EndpointClass(_$2.assign({
        _on: this._on,
        _emit: this._emit,
        _node: this,
        _limitNum: obj.limitNum || this._endpointLimitNum,
        _global: this.global
      }, obj));
      this.emit('InnerEvents', {
        type: 'node:addEndpoint',
        data: endpoint
      });
      this.endpoints.push(endpoint);
      return endpoint;
    }
  }, {
    key: "removeEndpoint",
    value: function removeEndpoint(pointId) {
      var rmEndpointIndex = _$2.findIndex(this.endpoints, function (point) {
        return point.id === pointId;
      });

      if (rmEndpointIndex !== -1) {
        var rmEndpoint = this.endpoints.splice(rmEndpointIndex, 1)[0];
        this.emit('InnerEvents', {
          type: 'node:removeEndpoint',
          data: rmEndpoint
        });
        rmEndpoint.destroy();
        return rmEndpoint;
      }
    }
  }, {
    key: "getEndpoint",
    value: function getEndpoint(pointId, type) {
      return _$2.find(this.endpoints, function (point) {
        if (!point.type || point.type === 'onlyConnect') {
          return pointId === point.id;
        } else {
          return pointId === point.id && (type && type === point.type || !type);
        }
      });
    }
  }, {
    key: "_init",
    value: function _init() {
      var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this._isInited) {
        return;
      } // 这里可以抽象下，和constructor对比


      if (obj.left) {
        this.left = obj.left;
      }

      if (obj.top) {
        this.top = obj.top;
      }

      if (obj._isDeleteGroup) {
        this.group = undefined;
        this._group = undefined;
      } else {
        obj.group && (this.group = obj.group);
      }

      delete obj._isDeleteGroup;
      this._isInited = true;

      if (obj.dom) {
        this.dom = obj.dom;
        obj.left && $$1(this.dom).css('left', "".concat(obj.left, "px"));
        obj.top && $$1(this.dom).css('top', "".concat(obj.top, "px"));
      } else {
        this.dom = this.draw(_$2.assign({
          id: this.id,
          top: this.top,
          left: this.left,
          dom: this.dom,
          options: this.options
        }, obj));

        this._addEventListener();
      }
    } // drag的时候移动的api

  }, {
    key: "_moveTo",
    value: function _moveTo(x, y) {
      var _this2 = this;

      // 自身移动
      $$1(this.dom).css('top', y).css('left', x); // 所在的点移动

      this.endpoints.forEach(function (item) {
        item.moveTo(x - _this2.left + item._left, y - _this2.top + item._top);
      });
      this.top = y;
      this.left = x;
    }
  }, {
    key: "moveTo",
    value: function moveTo(x, y, isNotEventEmit) {
      this.emit('InnerEvents', {
        type: 'node:move',
        node: this,
        x: x,
        y: y,
        isNotEventEmit: isNotEventEmit
      });
    }
  }, {
    key: "getWidth",
    value: function getWidth() {
      return $$1(this.dom).outerWidth();
    }
  }, {
    key: "getHeight",
    value: function getHeight() {
      return $$1(this.dom).outerHeight();
    }
  }, {
    key: "_createEndpoint",
    value: function _createEndpoint(isInited) {
      var _this3 = this;

      if (isInited) {
        this.endpoints.forEach(function (item) {
          return _this3.addEndpoint(item, isInited);
        });
      } else if (this._endpointsData) {
        this._endpointsData.map(function (item) {
          return _this3.addEndpoint(item);
        });
      }
    }
  }, {
    key: "_addEventListener",
    value: function _addEventListener() {
      var _this4 = this;

      // todo 做事件代理的形式
      $$1(this.dom).on('mousedown', function (e) {
        var LEFT_KEY = 0;

        if (e.button !== LEFT_KEY) {
          return;
        }

        if (!['SELECT', 'INPUT', 'RADIO', 'CHECKBOX', 'TEXTAREA'].includes(e.target.nodeName)) {
          e.preventDefault();
        }

        if (_this4.draggable) {
          _this4._isMoving = true;

          _this4.emit('InnerEvents', {
            type: 'node:dragBegin',
            data: _this4
          });
        } else {
          // 单纯为了抛错事件给canvas，为了让canvas的dragtype不为空，不会触发canvas:click事件
          _this4.emit('InnerEvents', {
            type: 'node:mouseDown',
            data: _this4
          });
        }
      });
      $$1(this.dom).on('click', function (e) {
        e.preventDefault();
        e.stopPropagation();

        _this4.emit('system.node.click', {
          node: _this4
        });

        _this4.emit('events', {
          type: 'node:click',
          node: _this4
        });
      });
      this.setDraggable(this.draggable);
    }
  }, {
    key: "setDraggable",
    value: function setDraggable(draggable) {
      this.draggable = draggable;
    }
  }, {
    key: "remove",
    value: function remove() {
      this.emit('InnerEvents', {
        type: 'node:delete',
        data: this
      });
    }
  }, {
    key: "emit",
    value: function emit(type, data) {
      _get(_getPrototypeOf(BaseNode.prototype), "emit", this).call(this, type, data);

      this._emit(type, data);
    }
  }, {
    key: "destroy",
    value: function destroy(isNotEvent) {
      if (!isNotEvent) {
        this.endpoints.forEach(function (item) {
          !item._isInitedDom && item.destroy();
        });
        $$1(this.dom).remove();
        this.removeAllListeners();
      } else {
        this.endpoints.forEach(function (item) {
          !item._isInitedDom && item.destroy(isNotEvent);
        });
        $$1(this.dom).detach();
      }

      this._isInited = false;
    }
  }]);

  return BaseNode;
}(Node$1);

var _$3 = require('lodash');

var MINDIST = 20;
var TOL = 0.1;
var TOLxTOL = 0.01;
var LEFT = 'Left';
var RIGHT = 'Right';
var TOP = 'Top';
var BOTTOM = 'Bottom';

var Point = function Point(x, y) {
  this.x = x;
  this.y = y;
};

function drawBezier(sourcePoint, targetPoint) {
  if (!sourcePoint.orientation) {
    sourcePoint.orientation = _calcOrientation(targetPoint.pos[0], targetPoint.pos[1], sourcePoint.pos[0], sourcePoint.pos[1]);
  }

  if (!targetPoint.orientation) {
    targetPoint.orientation = _calcOrientation(sourcePoint.pos[0], sourcePoint.pos[1], targetPoint.pos[0], targetPoint.pos[1]);
  } // 控制点


  var _width = Math.abs(sourcePoint.pos[0] - targetPoint.pos[0]);

  var _height = Math.abs(sourcePoint.pos[1] - targetPoint.pos[1]);

  var _sx = sourcePoint.pos[0] < targetPoint.pos[0] ? _width : 0;

  var _sy = sourcePoint.pos[1] < targetPoint.pos[1] ? _height : 0;

  var _tx = sourcePoint.pos[0] < targetPoint.pos[0] ? 0 : _width;

  var _ty = sourcePoint.pos[1] < targetPoint.pos[1] ? 0 : _height;

  var _so = sourcePoint.orientation;
  var _to = targetPoint.orientation;

  var sourceCtrlPoint = _findControlPoint([_sx, _sy], sourcePoint, targetPoint, _so, _to);

  var targetCtrlPoint = _findControlPoint([_tx, _ty], targetPoint, sourcePoint, _to, _so);

  var offsetX = sourcePoint.pos[0] < targetPoint.pos[0] ? sourcePoint.pos[0] : targetPoint.pos[0];
  var offsetY = sourcePoint.pos[1] < targetPoint.pos[1] ? sourcePoint.pos[1] : targetPoint.pos[1];
  sourceCtrlPoint = [sourceCtrlPoint[0] + offsetX, sourceCtrlPoint[1] + offsetY];
  targetCtrlPoint = [targetCtrlPoint[0] + offsetX, targetCtrlPoint[1] + offsetY]; // 起始点

  var result = ['M', sourcePoint.pos[0], sourcePoint.pos[1]]; // 两个控制点

  result = result.concat(['C', targetCtrlPoint[0], targetCtrlPoint[1], sourceCtrlPoint[0], sourceCtrlPoint[1]]); // 结束点

  result = result.concat([targetPoint.pos[0], targetPoint.pos[1]]);
  return result.join(' ');
}

function drawAdvancedBezier(sourcePoint, targetPoint) {
  if (!sourcePoint.orientation) {
    sourcePoint.orientation = _calcOrientation(targetPoint.pos[0], targetPoint.pos[1], sourcePoint.pos[0], sourcePoint.pos[1]);
  }

  if (!targetPoint.orientation) {
    targetPoint.orientation = _calcOrientation(sourcePoint.pos[0], sourcePoint.pos[1], targetPoint.pos[0], targetPoint.pos[1]);
  } // 控制点


  var _width = Math.abs(sourcePoint.pos[0] - targetPoint.pos[0]);

  var _height = Math.abs(sourcePoint.pos[1] - targetPoint.pos[1]);

  var _so = sourcePoint.orientation;
  var _to = targetPoint.orientation;
  var dist = Math.sqrt(_width * _width + _height * _height); // 控制点百分比，可转配置

  var percent = 0.25; // 偏差量，可转配置

  var minorDist = 30;
  var so_offsetX = 0;
  var so_offsetY = 0;

  if (_so[0] !== 0) {
    so_offsetX = (dist * percent + minorDist) * _so[0];
  } else if (_so[1] !== 0) {
    so_offsetY = (dist * percent + minorDist) * _so[1];
  }

  var to_offsetX = 0;
  var to_offsetY = 0;

  if (_to[0] !== 0) {
    to_offsetX = (dist * percent + minorDist) * _to[0];
  } else if (_to[1] !== 0) {
    to_offsetY = (dist * percent + minorDist) * _to[1];
  }

  var sourceCtrlPoint = [sourcePoint.pos[0] + so_offsetX, sourcePoint.pos[1] + so_offsetY];
  var targetCtrlPoint = [targetPoint.pos[0] + to_offsetX, targetPoint.pos[1] + to_offsetY]; // 起始点

  var result = ['M', sourcePoint.pos[0], sourcePoint.pos[1]]; // let result = ['M', targetPoint.pos[0], targetPoint.pos[1]];
  // 两个控制点

  result = result.concat(['C', sourceCtrlPoint[0], sourceCtrlPoint[1]], targetCtrlPoint[0], targetCtrlPoint[1]); // result = result.concat(['C', targetCtrlPoint[0], targetCtrlPoint[1], sourceCtrlPoint[0], sourceCtrlPoint[1]]);
  // 结束点

  result = result.concat([targetPoint.pos[0], targetPoint.pos[1]]); // result = result.concat([sourcePoint.pos[0], sourcePoint.pos[1]]);

  return result.join(' ');
}

function drawStraight(sourcePoint, targetPoint) {
  var result = ['M', sourcePoint.pos[0], sourcePoint.pos[1], 'L', targetPoint.pos[0], targetPoint.pos[1]];
  return result.join(' ');
}

function drawFlow(sourcePoint, targetPoint, orientationLimit) {
  if (!sourcePoint.orientation) {
    sourcePoint.orientation = _calcOrientation(targetPoint.pos[0], targetPoint.pos[1], sourcePoint.pos[0], sourcePoint.pos[1], orientationLimit);
  }

  if (!targetPoint.orientation) {
    targetPoint.orientation = _calcOrientation(sourcePoint.pos[0], sourcePoint.pos[1], targetPoint.pos[0], targetPoint.pos[1], orientationLimit);
  }

  var stub = 30; // 每部分折线的最小长度

  var midpoint = 0.5; // 折线中点

  var w = Math.abs(sourcePoint.pos[0] - targetPoint.pos[0]);
  var h = Math.abs(sourcePoint.pos[1] - targetPoint.pos[1]);
  var sx = targetPoint.pos[0] < sourcePoint.pos[0] ? w : 0;
  var sy = targetPoint.pos[1] < sourcePoint.pos[1] ? h : 0;
  var tx = targetPoint.pos[0] < sourcePoint.pos[0] ? 0 : w;
  var ty = targetPoint.pos[1] < sourcePoint.pos[1] ? 0 : h;
  var offsetX = sourcePoint.pos[0] < targetPoint.pos[0] ? sourcePoint.pos[0] : targetPoint.pos[0];
  var offsetY = sourcePoint.pos[1] < targetPoint.pos[1] ? sourcePoint.pos[1] : targetPoint.pos[1]; // 小心有可能so[0]和to[0]同时为0；或者是so[1]和to[1]同时为0

  var so = sourcePoint.orientation;
  var to = targetPoint.orientation; // 拿来判断是对面，垂直还是正交

  var oProduct = so[0] * to[0] + so[1] * to[1];
  var sourceAxis = so[0] === 0 ? 'y' : 'x';
  var startStubX = sx + so[0] * stub;
  var startStubY = sy + so[1] * stub;
  var endStubX = tx + to[0] * stub;
  var endStubY = ty + to[1] * stub;
  var isXGreaterThanStubTimes2 = Math.abs(sx - tx) > stub + stub;
  var isYGreaterThanStubTimes2 = Math.abs(sy - ty) > stub + stub; // 判断方向

  var anchorOrientation = null;

  if (oProduct === -1) {
    anchorOrientation = 'opposite';
  } else if (oProduct === 0) {
    anchorOrientation = 'perpendicular';
  } else if (oProduct === 1) {
    anchorOrientation = 'orthogonal';
  } // 计算折线的方法


  var _commonStubCalculator = function _commonStubCalculator() {
    return [startStubX, startStubY, endStubX, endStubY];
  };

  var stubCalculators = {
    perpendicular: _commonStubCalculator,
    orthogonal: _commonStubCalculator,
    opposite: function opposite(axis) {
      var idx = axis === 'x' ? 0 : 1;
      var areInProximity = {
        x: function x() {
          return so[idx] === 1 && (startStubX > endStubX && tx > startStubX || sx > endStubX && tx > sx) || so[idx] === -1 && (startStubX < endStubX && tx < startStubX || sx < endStubX && tx < sx);
        },
        y: function y() {
          return so[idx] === 1 && (startStubY > endStubY && ty > startStubY || sy > endStubY && ty > sy) || so[idx] === -1 && (startStubY < endStubY && ty < startStubY || sy < endStubY && ty < sy);
        }
      }; // 判断是否需要折线

      if (areInProximity[axis]()) {
        // 这判断可以设置总是有折线
        return {
          x: [(sx + tx) / 2, startStubY, (sx + tx) / 2, endStubY],
          y: [startStubX, (sy + ty) / 2, endStubX, (sy + ty) / 2]
        }[axis];
      } else {
        return [startStubX, startStubY, endStubX, endStubY];
      }
    }
  }; // 加工线条处理的方法

  var lastx = null;
  var lasty = null;
  var segments = [];

  var _sgn = function _sgn(n) {
    return n < 0 ? -1 : n === 0 ? 0 : 1;
  };

  var _addSegment = function _addSegment(x, y) {
    if (lastx === x && lasty === y) {
      return;
    }

    var lx = lastx == null ? sx : lastx;
    var ly = lasty == null ? sy : lasty;
    var o = lx === x ? 'v' : 'h';

    var sgnx = _sgn(x - lx);

    var sgny = _sgn(y - ly);

    lastx = x;
    lasty = y;
    segments.push([lx, ly, x, y, o, sgnx, sgny]);
  }; // 开始实现


  var stubs = stubCalculators[anchorOrientation](sourceAxis);
  var idx = sourceAxis === 'x' ? 0 : 1;
  var oidx = sourceAxis === 'x' ? 0 : 1;
  var ss = stubs[idx];
  var oss = stubs[oidx];
  var es = stubs[idx + 2];
  var oes = stubs[oidx + 2];

  _addSegment(stubs[0], stubs[1]);

  var midx = startStubX + (endStubX - startStubX) * midpoint;
  var midy = startStubY + (endStubY - startStubY) * midpoint;
  var orientations = {
    x: [0, 1],
    y: [1, 0]
  };
  var _lineCalculators = {
    perpendicular: function perpendicular(axis) {
      var sis = {
        x: [[[1, 2, 3, 4], null, [2, 1, 4, 3]], null, [[4, 3, 2, 1], null, [3, 4, 1, 2]]],
        y: [[[3, 2, 1, 4], null, [2, 3, 4, 1]], null, [[4, 1, 2, 3], null, [1, 4, 3, 2]]]
      };
      var stubs = {
        x: [[startStubX, endStubX], null, [endStubX, startStubX]],
        y: [[startStubY, endStubY], null, [endStubY, startStubY]]
      };
      var midLines = {
        x: [[midx, startStubY], [midx, endStubY]],
        y: [[startStubX, midy], [endStubX, midy]]
      };
      var linesToEnd = {
        x: [[endStubX, startStubY]],
        y: [[startStubX, endStubY]]
      };
      var startToEnd = {
        x: [[startStubX, endStubY], [endStubX, endStubY]],
        y: [[endStubX, startStubY], [endStubX, endStubY]]
      };
      var startToMidToEnd = {
        x: [[startStubX, midy], [endStubX, midy], [endStubX, endStubY]],
        y: [[midx, startStubY], [midx, endStubY], [endStubX, endStubY]]
      };
      var otherStubs = {
        x: [startStubY, endStubY],
        y: [startStubX, endStubX]
      };
      var soIdx = orientations[axis][0];
      var toIdx = orientations[axis][1];

      var _so = so[soIdx] + 1;

      var _to = to[toIdx] + 1;

      var otherFlipped = to[toIdx] === -1 && otherStubs[axis][1] < otherStubs[axis][0] || to[toIdx] === 1 && otherStubs[axis][1] > otherStubs[axis][0];
      var stub1 = stubs[axis][_so][0];
      var stub2 = stubs[axis][_so][1];
      var segmentIndexes = sis[axis][_so][_to]; // 计算一下节点象限

      var _quadrant = function _quadrant(p1, p2) {
        if (p2.pos[0] > p1.pos[0]) {
          return p2.pos[1] > p1.pos[1] ? 2 : 1;
        } else if (p2.pos[0] == p1.pos[0]) {
          return p2.pos[1] > p1.pos[1] ? 2 : 1;
        } else {
          return p2.pos[1] > p1.pos[1] ? 3 : 4;
        }
      };

      var segment = _quadrant(sourcePoint, targetPoint);

      if (segment === segmentIndexes[3] || segment === segmentIndexes[2] && otherFlipped) {
        return midLines[axis];
      } else if (segment === segmentIndexes[2] && stub2 < stub1) {
        return linesToEnd[axis];
      } else if (segment === segmentIndexes[2] && stub2 >= stub1 || segment === segmentIndexes[1] && !otherFlipped) {
        return startToMidToEnd[axis];
      } else if (segment === segmentIndexes[0] || segment === segmentIndexes[1] && otherFlipped) {
        return startToEnd[axis];
      }
    },
    orthogonal: function orthogonal(axis, startStub, otherStartStub, endStub, otherEndStub) {
      var extent = {
        x: so[0] === -1 ? Math.min(startStub, endStub) : Math.max(startStub, endStub),
        y: so[1] === -1 ? Math.min(startStub, endStub) : Math.max(startStub, endStub)
      }[axis];
      return {
        x: [[extent, otherStartStub], [extent, otherEndStub], [endStub, otherEndStub]],
        y: [[otherStartStub, extent], [otherEndStub, extent], [otherEndStub, endStub]]
      }[axis];
    },
    opposite: function opposite(axis, ss, oss, es) {
      var comparator = axis === 'x' ? isXGreaterThanStubTimes2 : isYGreaterThanStubTimes2; // 考虑下自连的情况, 现在很不严禁

      if (sourcePoint.pos[0] === targetPoint.pos[0] && sourcePoint.pos[1] === targetPoint.pos[1]) ; else if (!comparator || so[idx] === 1 && ss > es || so[idx] === -1 && ss < es) {
        return {
          x: [[ss, midy], [es, midy]],
          y: [[midx, ss], [midx, es]]
        }[axis];
      } else if (so[idx] === 1 && ss < es || so[idx] === -1 && ss > es) {
        return {
          x: [[midx, sy], [midx, ty]],
          y: [[sx, midy], [tx, midy]]
        }[axis];
      }
    }
  }; // 计算剩余线条

  var p = _lineCalculators[anchorOrientation](sourceAxis, ss, oss, es, oes);

  if (p) {
    for (var i = 0; i < p.length; p++) {
      _addSegment(p[i][0], p[i][1]);
    }
  } // line to end stub


  _addSegment(stubs[2], stubs[3]); // end stub to end (common)


  _addSegment(tx, ty); // 实际操作svg


  return _drawFlowSegment(segments, {
    x: offsetX,
    y: offsetY
  });
}

function drawManhattan(sourcePoint, targetPoint) {
  if (!sourcePoint.orientation) {
    sourcePoint.orientation = _calcOrientation(targetPoint.pos[0], targetPoint.pos[1], sourcePoint.pos[0], sourcePoint.pos[1]);
  }

  if (!targetPoint.orientation) {
    targetPoint.orientation = _calcOrientation(sourcePoint.pos[0], sourcePoint.pos[1], targetPoint.pos[0], targetPoint.pos[1]);
  }

  var pointArr = [];
  var fromPt = {
    x: sourcePoint.pos[0],
    y: sourcePoint.pos[1]
  };
  var toPt = {
    x: targetPoint.pos[0],
    y: targetPoint.pos[1]
  };
  var orientation = {
    '-10': LEFT,
    '10': RIGHT,
    '0-1': TOP,
    '01': BOTTOM
  }; // link:connect 中 orientation = undefined

  _route(pointArr, fromPt, orientation[sourcePoint.orientation.join('')], toPt, orientation[targetPoint.orientation.join('')]);

  if (pointArr.length < 2) return '';
  var path = pointArr.reduce(function (path, point) {
    path.push(['L', point.x, point.y].join(' '));
    return path;
  }, [['M', pointArr[0].x, pointArr[0].y].join(' ')]).join(' ');
  return path;
}

function _drawFlowSegment(segments, offset) {
  var current = null;
  var next = null;

  var lw = 1; // strokeWidth，线条的粗细

  var result = [];

  var _drawStraight = function _drawStraight(d) {
    return ['M', d.x1 + offset.x, d.y1 + offset.y, 'L', d.x2 + offset.x, d.y2 + offset.y];
  };
  // let offsetY = sourcePoint.pos[1] < targetPoint.pos[1] ? sourcePoint.pos[1] : targetPoint.pos[1];


  for (var i = 0; i < segments.length - 1; i++) {
    current = current || _$3.cloneDeep(segments[i]);
    next = _$3.cloneDeep(segments[i + 1]);

    {
      // dx + dy are used to adjust for line width.
      var dx = current[2] === current[0] ? 0 : current[2] > current[0] ? lw / 2 : -(lw / 2);
      var dy = current[3] === current[1] ? 0 : current[3] > current[1] ? lw / 2 : -(lw / 2);

      var _line = _drawStraight({
        x1: current[0] - dx,
        y1: current[1] - dy,
        x2: current[2] + dx,
        y2: current[3] + dy
      });

      result = result.concat(_line);
    }

    current = next;
  }

  if (next !== null) {
    var _line3 = _drawStraight({
      x1: next[0],
      y1: next[1],
      x2: next[2],
      y2: next[3]
    });

    result = result.concat(_line3);
  }

  return result.join(' ');
}

function _calcOrientation(beginX, beginY, endX, endY, orientationLimit) {
  var _calcWithLimit = function _calcWithLimit(rank) {
    if (orientationLimit) {
      var _loop = function _loop(i) {
        var isInLimit = _$3.some(orientationLimit, function (limit) {
          return limit === rank[i];
        });

        if (isInLimit) {
          return {
            v: rank[i]
          };
        }
      };

      for (var i = 0; i < rank.length; i++) {
        var _ret = _loop(i);

        if (_typeof(_ret) === "object") return _ret.v;
      }

      return rank[0];
    } else {
      return rank[0];
    }
  }; // 计算orientation


  var posX = endX - beginX;
  var posY = endY - beginY;
  var orientation = null; // 斜率

  var k = Math.abs(posY / posX);

  if (posX === 0 || posY === 0) {
    if (posX === 0) {
      orientation = posY >= 0 ? _calcWithLimit(['Top', 'Left', 'Right', 'Bottom']) : orientation;
      orientation = posY < 0 ? _calcWithLimit(['Bottom', 'Left', 'Right', 'Top']) : orientation;
    }

    if (posY === 0) {
      orientation = posX >= 0 ? _calcWithLimit(['Right', 'Top', 'Bottom', 'Left']) : orientation;
      orientation = posX < 0 ? _calcWithLimit(['Left', 'Top', 'Bottom', 'Right']) : orientation;
    }
  } else if (posX > 0 && posY > 0) {
    if (k > 1) {
      orientation = _calcWithLimit(['Top', 'Left', 'Right', 'Bottom']); // orientation = [0, -1];
    } else {
      orientation = _calcWithLimit(['Left', 'Top', 'Bottom', 'Right']); // orientation = [-1, 0];
    }
  } else if (posX < 0 && posY > 0) {
    if (k > 1) {
      orientation = _calcWithLimit(['Top', 'Right', 'Left', 'Bottom']); // orientation = [0, -1];
    } else {
      orientation = _calcWithLimit(['Right', 'Top', 'Bottom', 'Left']); // orientation = [1, 0];
    }
  } else if (posX < 0 && posY < 0) {
    if (k > 1) {
      orientation = _calcWithLimit(['Bottom', 'Right', 'Left', 'Top']); // orientation = [0, 1];
    } else {
      orientation = _calcWithLimit(['Right', 'Bottom', 'Top', 'Left']); // orientation = [1, 0];
    }
  } else {
    if (k > 1) {
      orientation = _calcWithLimit(['Bottom', 'Left', 'Right', 'Top']); // orientation = [0, 1];
    } else {
      orientation = _calcWithLimit(['Left', 'Bottom', 'Top', 'Right']); // orientation = [-1, 0];
    }
  }

  switch (orientation) {
    case 'Left':
      return [-1, 0];

    case 'Right':
      return [1, 0];

    case 'Top':
      return [0, -1];

    case 'Bottom':
      return [0, 1];
  }
}

function _findControlPoint(point, sourcePoint, targetPoint, _so, _to) {
  // 曲率，可配置的
  var majorAnchor = 10; // 偏移，定死的

  var minorAnchor = 10;
  var result = []; // 特殊处理完全水平和垂直的情况

  if (sourcePoint.pos[0] === targetPoint.pos[0] && _so[1] !== _to[1] && _so[0] === 0 && _to[0] === 0) {
    result = [point[0], point[1] + majorAnchor * _so[1]];
    return result;
  }

  if (sourcePoint.pos[1] === targetPoint.pos[1] && _so[0] !== _to[0] && _so[1] === 0 && _to[1] === 0) {
    result = [point[0] + majorAnchor * _so[0], point[1]];
    return result;
  } // 平常情况


  var perpendicular = _so[0] !== _to[0] || _so[1] === _to[1];

  if (!perpendicular) {
    if (_so[0] === 0) {
      result.push(sourcePoint.pos[0] < targetPoint.pos[0] ? point[0] + minorAnchor : point[0] - minorAnchor);
    } else {
      result.push(point[0] - majorAnchor * _so[0]);
    }

    if (_so[1] === 0) {
      result.push(sourcePoint.pos[1] < targetPoint.pos[1] ? point[1] + minorAnchor : point[1] - minorAnchor);
    } else {
      result.push(point[1] - majorAnchor * _to[1]);
    }
  } else {
    if (_to[0] === 0) {
      result.push(targetPoint.pos[0] < sourcePoint.pos[0] ? point[0] + minorAnchor : point[0] - minorAnchor);
    } else {
      result.push(point[0] + majorAnchor * _to[0]);
    }

    if (_to[1] === 0) {
      result.push(targetPoint.pos[1] < sourcePoint.pos[1] ? point[1] + minorAnchor : point[1] - minorAnchor);
    } else {
      result.push(point[1] + majorAnchor * _so[1]);
    }
  }

  return result;
} // 曼哈顿折线路由算法


function _route(conn, fromPt, fromDir, toPt, toDir) {
  // 防止图上节点隐藏NaN的死循环问题
  fromPt.x = fromPt.x || 0;
  fromPt.y = fromPt.y || 0;
  toPt.x = toPt.x || 0;
  toPt.y = toPt.y || 0;
  var xDiff = fromPt.x - toPt.x;
  var yDiff = fromPt.y - toPt.y;
  var point;
  var dir;
  var pos;
  conn.push(new Point(fromPt.x, fromPt.y));

  if (xDiff * xDiff < TOLxTOL && yDiff * yDiff < TOLxTOL) {
    conn.push(new Point(toPt.x, toPt.y));
    return;
  }

  if (fromDir === LEFT) {
    if (xDiff > 0 && yDiff * yDiff < TOL && toDir === RIGHT) {
      point = toPt;
      dir = toDir;
    } else {
      if (xDiff < 0) {
        point = new Point(fromPt.x - MINDIST, fromPt.y);
      } else if (yDiff > 0 && toDir === BOTTOM || yDiff < 0 && toDir === TOP) {
        point = new Point(toPt.x, fromPt.y);
      } else if (fromDir === toDir) {
        pos = Math.min(fromPt.x, toPt.x) - MINDIST;
        point = new Point(pos, fromPt.y);
      } else {
        point = new Point(fromPt.x - xDiff / 2, fromPt.y);
      }

      if (yDiff > 0) {
        dir = TOP;
      } else {
        dir = BOTTOM;
      }
    }
  } else if (fromDir === RIGHT) {
    if (xDiff < 0 && yDiff * yDiff < TOL && toDir === LEFT) {
      point = toPt;
      dir = toDir;
    } else {
      if (xDiff > 0) {
        point = new Point(fromPt.x + MINDIST, fromPt.y);
      } else if (yDiff > 0 && toDir === BOTTOM || yDiff < 0 && toDir === TOP) {
        point = new Point(toPt.x, fromPt.y);
      } else if (fromDir === toDir) {
        pos = Math.max(fromPt.x, toPt.x) + MINDIST;
        point = new Point(pos, fromPt.y);
      } else {
        point = new Point(fromPt.x - xDiff / 2, fromPt.y);
      }

      if (yDiff > 0) {
        dir = TOP;
      } else {
        dir = BOTTOM;
      }
    }
  } else if (fromDir === BOTTOM) {
    if (xDiff * xDiff < TOL && yDiff < 0 && toDir === TOP) {
      point = toPt;
      dir = toDir;
    } else {
      if (yDiff > 0) {
        point = new Point(fromPt.x, fromPt.y + MINDIST);
      } else if (xDiff > 0 && toDir === RIGHT || xDiff < 0 && toDir === LEFT) {
        point = new Point(fromPt.x, toPt.y);
      } else if (fromDir === toDir) {
        pos = Math.max(fromPt.y, toPt.y) + MINDIST;
        point = new Point(fromPt.x, pos);
      } else {
        point = new Point(fromPt.x, fromPt.y - yDiff / 2);
      }

      if (xDiff > 0) {
        dir = LEFT;
      } else {
        dir = RIGHT;
      }
    }
  } else if (fromDir === TOP) {
    if (xDiff * xDiff < TOL && yDiff > 0 && toDir === BOTTOM) {
      point = toPt;
      dir = toDir;
    } else {
      if (yDiff < 0) {
        point = new Point(fromPt.x, fromPt.y - MINDIST);
      } else if (xDiff > 0 && toDir === RIGHT || xDiff < 0 && toDir === LEFT) {
        point = new Point(fromPt.x, toPt.y);
      } else if (fromDir === toDir) {
        pos = Math.min(fromPt.y, toPt.y) - MINDIST;
        point = new Point(fromPt.x, pos);
      } else {
        point = new Point(fromPt.x, fromPt.y - yDiff / 2);
      }

      if (xDiff > 0) {
        dir = LEFT;
      } else {
        dir = RIGHT;
      }
    }
  }

  _route(conn, point, dir, toPt, toDir);
}

var DrawUtil = {
  drawBezier: drawBezier,
  drawAdvancedBezier: drawAdvancedBezier,
  drawStraight: drawStraight,
  drawFlow: drawFlow,
  drawManhattan: drawManhattan
};

var arrow = {
  default1: 'M0 0 L-3 3 L2 0 L-3 -3 Z',
  "default": "M5 0 L0 -2 Q 1.0 0 0 2 Z",
  length: 5
}; // 计算线条某个位置的斜率

function calcSlope(opts) {
  var shapeType = _$f.get(opts, 'shapeType');

  var dom = _$f.get(opts, 'dom');

  var arrowPosition = _$f.get(opts, 'arrowPosition', 0.5);

  var path = _$f.get(opts, 'path');

  var coordinates = path.split(' ');
  var x = 0;
  var y = 0;

  if (shapeType === 'BezierTest' || shapeType === 'AdvancedBezierTest') {
    var p0 = {
      x: coordinates[8],
      y: coordinates[9]
    };
    var p1 = {
      x: coordinates[1],
      y: coordinates[2]
    };

    if (arrowPosition !== 1) {
      p0 = dom.getPointAtLength(dom.getTotalLength() * arrowPosition + 0.001);
      p1 = dom.getPointAtLength(dom.getTotalLength() * arrowPosition);
    } else {
      p0 = dom.getPointAtLength(dom.getTotalLength() * arrowPosition);
      p1 = dom.getPointAtLength(dom.getTotalLength() * arrowPosition - 0.001);
    }

    x = p1.x - p0.x;
    y = p1.y - p0.y;
  } else if (shapeType === 'Straight') {
    var _p = {
      x: coordinates[1],
      y: coordinates[2]
    };
    var _p2 = {
      x: coordinates[4],
      y: coordinates[5]
    };
    x = _p2.x - _p.x;
    y = _p2.y - _p.y;
  } else {
    var _p3 = 0;
    var _p4 = 1;

    if (arrowPosition !== 1) {
      _p3 = dom.getPointAtLength(dom.getTotalLength() * arrowPosition);
      _p4 = dom.getPointAtLength(dom.getTotalLength() * arrowPosition + 0.001);
    } else {
      _p3 = dom.getPointAtLength(dom.getTotalLength() * arrowPosition - 0.001);
      _p4 = dom.getPointAtLength(dom.getTotalLength() * arrowPosition);
    }

    x = _p4.x - _p3.x;
    y = _p4.y - _p3.y;
  }

  return {
    x: x,
    y: y
  };
}

var ArrowUtil = {
  calcSlope: calcSlope,
  arrow: arrow
};

var $$2 = require('jquery');

var _initTime = new Date().getTime();

var init = function init(_svg) {
  _initTime = new Date().getTime();
};

var addAnimate = function addAnimate(targetDom, path) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var animateDom = arguments.length > 3 ? arguments[3] : undefined;
  var _animateDom = animateDom;
  var circle = null;
  var motion = null;

  if (!_animateDom) {
    circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    motion = document.createElementNS('http://www.w3.org/2000/svg', 'animateMotion');
    circle.append(motion);
  }

  if (options._isContinue) {
    $$2(_animateDom).find('animateMotion').attr('path', path);
  } else {
    var _startTime = (new Date().getTime() - _initTime) / 1000;

    if (_animateDom) {
      circle = _animateDom;
      motion = $$2(_animateDom).find('animateMotion')[0];
      $$2(circle).css('display', 'block');
    }

    circle.setAttribute('cx', 0);
    circle.setAttribute('cy', 0);
    circle.setAttribute('r', options.radius || 2);
    circle.setAttribute('fill', options.color || '#999');
    motion.setAttribute('path', path);
    motion.setAttribute('begin', "".concat(_startTime, "s"));
    motion.setAttribute('dur', options.dur || '8s');
    motion.setAttribute('fill', 'freeze');
    motion.setAttribute('repeatCount', options.repeatCount || 'indefinite');

    if (options.repeatCount && options.repeatCount !== 'indefinite') {
      setTimeout(function () {
        $$2(circle).css('display', 'none');
      }, parseFloat(options.dur) * parseInt(options.repeatCount) * 1000);
    }
  }

  if (!_animateDom) {
    _animateDom = circle;
    $$2(_animateDom).insertAfter(targetDom);
  }

  return _animateDom;
};

var LinkAnimateUtil = {
  init: init,
  addAnimate: addAnimate
};

var EventEmit3$3 = require('eventemitter3');

var Edge = /*#__PURE__*/function (_EventEmit) {
  _inherits(Edge, _EventEmit);

  var _super = _createSuper(Edge);

  function Edge() {
    _classCallCheck(this, Edge);

    // id                 节点唯一标志
    // targetNode         目标节点
    // targetEndpoint     目标锚点
    // sourceNode         源节点
    // sourceEndpoint     源锚点
    // type               "node" or "endpoint"，标志类型的
    // shapeType          线条类型
    // label              设置线条上的字体
    // options            数据的透传
    // dom                线条dom
    // labelDom           label的dom
    // arrowDom           箭头的dom
    // 箭头部分看看需要优化不？
    // arrow              是否有箭头
    // arrowPosition      箭头的位置
    // arrowOffset        箭头起始点
    // 需要优化的
    // isExpandWidth      拓展线条
    // eventHandlerDom    代替绑定事件的dom
    // orientationLimit   限制方向
    // 需要优化的
    // scope           scope相同可拉进group里面
    // endpoints       endpoint对象
    // _endpointsData  真实的endpoint数据
    // 需要悬空
    return _super.call(this);
  } // 渲染节点


  _createClass(Edge, [{
    key: "draw",
    value: function draw() {} // 重绘节点

  }, {
    key: "redraw",
    value: function redraw() {} // 渲染label

  }, {
    key: "drawLabel",
    value: function drawLabel() {} // 重绘label

  }, {
    key: "redrawLabel",
    value: function redrawLabel() {} // 渲染arrow

  }, {
    key: "drawArrow",
    value: function drawArrow() {} // 重回arrow

  }, {
    key: "redrawArrow",
    value: function redrawArrow() {} // 判断是否能连接的方法

  }, {
    key: "isConnect",
    value: function isConnect() {} // 销毁节点

  }, {
    key: "destroy",
    value: function destroy() {} // ********* 需要新增的api ********* 
    // 删除线条

  }, {
    key: "remove",
    value: function remove() {} // 单击的回调

  }, {
    key: "click",
    value: function click() {} // hover的回调

  }, {
    key: "hover",
    value: function hover() {} // focus回调

  }, {
    key: "focus",
    value: function focus() {} // unFocus回调

  }, {
    key: "unFocus",
    value: function unFocus() {}
  }]);

  return Edge;
}(EventEmit3$3);

var _$4 = require('lodash');

var $$3 = require('jquery');

var BaseEdge = /*#__PURE__*/function (_Edge) {
  _inherits(BaseEdge, _Edge);

  var _super = _createSuper(BaseEdge);

  function BaseEdge(opts) {
    var _this;

    _classCallCheck(this, BaseEdge);

    _this = _super.call(this, opts);
    _this.id = _$4.get(opts, 'id');
    _this.targetNode = _$4.get(opts, 'targetNode');
    _this._targetType = _$4.get(opts, '_targetType');
    _this.targetEndpoint = _$4.get(opts, 'targetEndpoint');
    _this.sourceNode = _$4.get(opts, 'sourceNode');
    _this._sourceType = _$4.get(opts, '_sourceType');
    _this.sourceEndpoint = _$4.get(opts, 'sourceEndpoint');
    _this.type = _$4.get(opts, 'type') || 'endpoint';
    _this.orientationLimit = _$4.get(opts, 'orientationLimit');
    _this.shapeType = _$4.get(opts, 'shapeType');
    _this.label = _$4.get(opts, 'label');
    _this.arrow = _$4.get(opts, 'arrow');
    _this.arrowPosition = _$4.get(opts, 'arrowPosition', 0.5);
    _this.arrowOffset = _$4.get(opts, 'arrowOffset', 0), _this.isExpandWidth = _$4.get(opts, 'isExpandWidth', false);
    _this.defaultAnimate = _$4.get(opts, 'defaultAnimate', false);
    _this.dom = null;
    _this.labelDom = null;
    _this.arrowDom = null;
    _this.eventHandlerDom = null; // 鸭子辨识手动判断类型

    _this.__type = 'edge';
    _this._path = null; // 业务和库内addEdges写法上有区别，需要兼容

    _this.options = _$4.get(opts, 'options') || opts;
    _this._isDeletingEdge = opts._isDeletingEdge;
    _this._global = opts._global;
    _this._on = opts._on;
    _this._emit = opts._emit; // 性能优化

    _this._labelWidth = 0;
    _this._labelHeight = 0; // 函数节流

    _this._updateTimer = null;
    _this._UPDATE_INTERVAL = 20;
    return _this;
  }

  _createClass(BaseEdge, [{
    key: "_init",
    value: function _init() {
      if (this._isInited) {
        return;
      }

      this._isInited = true;
      this.dom = this.draw({
        id: this.id,
        dom: this.dom,
        options: this.options
      });
      this.labelDom = this.drawLabel(this.label);
      this.arrowDom = this.drawArrow(this.arrow);

      this._addEventListener();
    }
  }, {
    key: "draw",
    value: function draw(obj) {
      var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('class', 'butterflies-link');

      if (this.isExpandWidth) {
        // 扩大线选中范围
        this.eventHandlerDom = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        this.eventHandlerDom.setAttribute('class', 'butterflies-link-event-handler');
      }

      return path;
    }
  }, {
    key: "mounted",
    value: function mounted() {
      if (this.defaultAnimate) {
        this.addAnimate();
      }
    }
  }, {
    key: "_calcPath",
    value: function _calcPath(sourcePoint, targetPoint) {
      if (!sourcePoint) {
        sourcePoint = {
          pos: [// this.type === 'endpoint' ? this.sourceEndpoint._posLeft + this.sourceEndpoint._width / 2 : this.sourceNode.left + this.sourceNode.dom.offsetWidth / 2,
          // this.type === 'endpoint' ? this.sourceEndpoint._posTop + this.sourceEndpoint._height / 2 : this.sourceNode.top + this.sourceNode.dom.offsetHeight / 2
          this.type === 'endpoint' ? this.sourceEndpoint._posLeft + this.sourceEndpoint._width / 2 : this.sourceNode.left + $$3(this.sourceNode.dom).width() / 2, this.type === 'endpoint' ? this.sourceEndpoint._posTop + this.sourceEndpoint._height / 2 : this.sourceNode.top + $$3(this.sourceNode.dom).height() / 2],
          orientation: this.type === 'endpoint' && this.sourceEndpoint.orientation ? this.sourceEndpoint.orientation : undefined
        };
      }

      if (!targetPoint) {
        targetPoint = {
          pos: [// this.type === 'endpoint' ? this.targetEndpoint._posLeft + this.targetEndpoint._width / 2 : this.targetNode.left + this.targetNode.dom.offsetWidth / 2,
          // this.type === 'endpoint' ? this.targetEndpoint._posTop + this.targetEndpoint._height / 2 : this.targetNode.top + this.targetNode.dom.offsetHeight / 2
          this.type === 'endpoint' ? this.targetEndpoint._posLeft + this.targetEndpoint._width / 2 : this.targetNode.left + $$3(this.targetNode.dom).width() / 2, this.type === 'endpoint' ? this.targetEndpoint._posTop + this.targetEndpoint._height / 2 : this.targetNode.top + $$3(this.targetNode.dom).height() / 2],
          orientation: this.type === 'endpoint' && this.targetEndpoint.orientation ? this.targetEndpoint.orientation : undefined
        };
      }

      var path = '';

      if (this.calcPath) {
        path = this.calcPath(sourcePoint, targetPoint);
      } else if (this.shapeType === 'Bezier') {
        path = DrawUtil.drawBezier(sourcePoint, targetPoint);
      } else if (this.shapeType === 'Straight') {
        path = DrawUtil.drawStraight(sourcePoint, targetPoint);
      } else if (this.shapeType === 'Flow') {
        path = DrawUtil.drawFlow(sourcePoint, targetPoint, this.orientationLimit);
      } else if (this.shapeType === 'Manhattan') {
        path = DrawUtil.drawManhattan(sourcePoint, targetPoint);
      } else if (this.shapeType === 'AdvancedBezier') {
        path = DrawUtil.drawAdvancedBezier(sourcePoint, targetPoint);
      }

      this._path = path;
      return path;
    }
  }, {
    key: "redrawLabel",
    value: function redrawLabel() {
      var pathLength = this.dom.getTotalLength() / 2;
      var centerPoint = this.dom.getPointAtLength(pathLength);
      $$3(this.labelDom).css('left', centerPoint.x - this.labelDom.offsetWidth / 2).css('top', centerPoint.y - this.labelDom.offsetHeight / 2);
    }
  }, {
    key: "drawLabel",
    value: function drawLabel(label) {
      var isDom = (typeof HTMLElement === "undefined" ? "undefined" : _typeof(HTMLElement)) === 'object' ? function (obj) {
        return obj instanceof HTMLElement;
      } : function (obj) {
        return obj && _typeof(obj) === 'object' && obj.nodeType === 1 && typeof obj.nodeName === 'string';
      };

      if (label) {
        if (isDom(label)) {
          $$3(label).addClass('butterflies-label');
          return label;
        } else {
          var dom = document.createElement('span');
          dom.className = 'butterflies-label';
          dom.innerText = label;
          return dom;
        }
      }
    }
  }, {
    key: "updateLabel",
    value: function updateLabel(label) {
      var labelDom = this.drawLabel(label);

      if (this.labelDom) {
        $$3(this.labelDom).off();
        $$3(this.labelDom).remove();
      }

      this.label = label;
      this.labelDom = labelDom;
      this.emit('InnerEvents', {
        type: 'edge:updateLabel',
        data: this
      });
    }
  }, {
    key: "redrawArrow",
    value: function redrawArrow(path) {
      var length = this.dom.getTotalLength();

      if (!length) {
        return;
      }

      this.arrowFinalPosition = (length * this.arrowPosition + this.arrowOffset) / length;

      if (this.arrowFinalPosition > 1) {
        this.arrowFinalPosition = 1;
      }

      if (this.arrowFinalPosition < 0) {
        this.arrowFinalPosition = 0;
      } // 防止箭头窜出线条


      if (1 - this.arrowFinalPosition < ArrowUtil.arrow.length / length) {
        this.arrowFinalPosition = (length * this.arrowFinalPosition - ArrowUtil.arrow.length) / length;
      } // 贝塞尔曲线是反着画的，需要调整


      if (this.shapeType === 'Bezier') {
        this.arrowFinalPosition = 1 - this.arrowFinalPosition;
      }

      var point = this.dom.getPointAtLength(length * this.arrowFinalPosition);
      var x = point.x;
      var y = point.y;
      var vector = ArrowUtil.calcSlope({
        shapeType: this.shapeType,
        dom: this.dom,
        arrowPosition: this.arrowFinalPosition,
        path: path
      });
      var deg = Math.atan2(vector.y, vector.x) / Math.PI * 180;
      this.arrowDom.setAttribute('d', ArrowUtil.arrow["default"]);
      this.arrowDom.setAttribute('transform', "rotate(".concat(deg, ", ").concat(x, ", ").concat(y, ")translate(").concat(x, ", ").concat(y, ")"));
    }
  }, {
    key: "drawArrow",
    value: function drawArrow(arrow) {
      if (arrow) {
        var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('class', 'butterflies-arrow');
        return path;
      }
    }
  }, {
    key: "redraw",
    value: function redraw(sourcePoint, targetPoint, options) {
      var _this2 = this;

      // 重新计算线条path
      var path = this._calcPath(sourcePoint, targetPoint);

      this.dom.setAttribute('d', path);

      if (this.isExpandWidth) {
        this.eventHandlerDom.setAttribute('d', path);
        $$3(this.eventHandlerDom).insertAfter(this.dom);
      } // 函数节流


      if (!this._updateTimer) {
        this._updateTimer = setTimeout(function () {
          // 重新计算label
          if (_this2.labelDom) {
            _this2.redrawLabel();
          } // 重新计算arrow


          if (_this2.arrowDom) {
            _this2.redrawArrow(path);
          } // 重新计算动画path


          if (_this2.animateDom) {
            _this2.redrawAnimate(path);
          }

          _this2._updateTimer = null;
        }, this._UPDATE_INTERVAL);
      }

      this.updated && this.updated();
    }
  }, {
    key: "isConnect",
    value: function isConnect() {
      return true;
    }
  }, {
    key: "addAnimate",
    value: function addAnimate(options) {
      this.animateDom = LinkAnimateUtil.addAnimate(this.dom, this._path, _$4.assign({}, {
        num: 1,
        // 现在只支持1个点点
        radius: 3,
        color: '#776ef3'
      }, options), this.animateDom);
    }
  }, {
    key: "redrawAnimate",
    value: function redrawAnimate(path) {
      LinkAnimateUtil.addAnimate(this.dom, this._path, {
        _isContinue: true
      }, this.animateDom);
    }
  }, {
    key: "emit",
    value: function emit(type, data) {
      _get(_getPrototypeOf(BaseEdge.prototype), "emit", this).call(this, type, data);

      this._emit(type, data);
    }
  }, {
    key: "remove",
    value: function remove() {
      this.emit('InnerEvents', {
        type: 'edge:delete',
        data: this
      });
    }
  }, {
    key: "destroy",
    value: function destroy(isNotEventEmit) {
      if (this.labelDom) {
        $$3(this.labelDom).remove();
      }

      if (this.arrowDom) {
        $$3(this.arrowDom).remove();
      }

      if (this.eventHandlerDom) {
        $$3(this.eventHandlerDom).remove();
      }

      if (this.animateDom) {
        $$3(this.animateDom).remove();
      }

      $$3(this.dom).remove();

      if (this.id && !isNotEventEmit) {
        this.removeAllListeners();
      }
    }
  }, {
    key: "_addEventListener",
    value: function _addEventListener() {
      var _this3 = this;

      $$3(this.dom).on('click', function (e) {
        e.preventDefault();
        e.stopPropagation();

        _this3.emit('system.link.click', {
          edge: _this3
        });

        _this3.emit('events', {
          type: 'link:click',
          edge: _this3
        });

        _this3.emit('InnerEvents', {
          type: 'link:click',
          data: _this3
        });
      });
    }
  }, {
    key: "_create",
    value: function _create(opts) {
      this.id = _$4.get(opts, 'id') || this.id;
      this.targetNode = _$4.get(opts, 'targetNode') || this.targetNode;
      this._targetType = _$4.get(opts, '_targetType') || this._targetType;
      this.targetEndpoint = _$4.get(opts, 'targetEndpoint') || this.targetEndpoint;
      this.sourceNode = _$4.get(opts, 'sourceNode') || this.sourceNode;
      this._sourceType = _$4.get(opts, '_sourceType') || this._sourceType;
      this.sourceEndpoint = _$4.get(opts, 'sourceEndpoint') || this.sourceEndpoint;
      this.type = _$4.get(opts, 'type') || this.type;

      _$4.set(this, 'options.targetNode', _$4.get(this, 'targetNode.id'));

      _$4.set(this, 'options.targetEndpoint', _$4.get(this, 'targetEndpoint.id'));

      this.redraw();
    }
  }]);

  return BaseEdge;
}(Edge);

var EventEmit3$4 = require('eventemitter3');

var Group = /*#__PURE__*/function (_EventEmit) {
  _inherits(Group, _EventEmit);

  var _super = _createSuper(Group);

  function Group() {
    _classCallCheck(this, Group);

    // id        节点唯一标志
    // top       坐标y
    // left      坐标x
    // width     节点组宽度
    // height    节点组高度
    // resize    标志是否能resize
    // dom       实际的dom
    // nodes     里面包含的节点对象
    // options   数据的透传
    // _on       节点发送事件
    // _emit     节点发送事件
    // _global   全局的配置
    // 需要优化的
    // scope           scope相同可拉进group里面
    // endpoints       endpoint对象
    // _endpointsData  真实的endpoint数据
    return _super.call(this);
  } // 渲染节点


  _createClass(Group, [{
    key: "draw",
    value: function draw() {} // 添加节点

  }, {
    key: "addNode",
    value: function addNode() {} // 批量添加节点

  }, {
    key: "addNodes",
    value: function addNodes() {} // 获取宽度

  }, {
    key: "getWidth",
    value: function getWidth() {} // 获取高度

  }, {
    key: "getHeight",
    value: function getHeight() {} // 删除节点

  }, {
    key: "removeNode",
    value: function removeNode() {} // 批量删除节点

  }, {
    key: "removeNodes",
    value: function removeNodes() {} // 设置是否可缩放

  }, {
    key: "setResize",
    value: function setResize() {} // 设置大小

  }, {
    key: "setSize",
    value: function setSize() {} // 移动group

  }, {
    key: "moveTo",
    value: function moveTo() {} // 获取锚点

  }, {
    key: "getEndpoint",
    value: function getEndpoint() {} // 添加锚点

  }, {
    key: "addEndpoint",
    value: function addEndpoint() {} // remove的方法

  }, {
    key: "remove",
    value: function remove() {} // 销毁的方法

  }, {
    key: "destroy",
    value: function destroy() {} // ********* 需要新增的api ********* 
    // 删除锚点

  }, {
    key: "removeEndpoint",
    value: function removeEndpoint() {} // 折叠的方法

  }, {
    key: "collapse",
    value: function collapse() {} // 伸展的方法

  }, {
    key: "stretch",
    value: function stretch() {} // 单击的回调

  }, {
    key: "click",
    value: function click() {} // 双击的回调

  }, {
    key: "doubleClick",
    value: function doubleClick() {} // 右键的回调

  }, {
    key: "onContextmenu",
    value: function onContextmenu() {} // hover的回调

  }, {
    key: "hover",
    value: function hover() {} // focus回调

  }, {
    key: "focus",
    value: function focus() {} // unFocus回调

  }, {
    key: "unFocus",
    value: function unFocus() {}
  }]);

  return Group;
}(EventEmit3$4);

var _$5 = require('lodash'); // 检验scope是否匹配


var ScopeCompare = (function (scope1, scope2, isScopeStrict) {
  var _scope1 = (scope1 || '').split(' ').filter(function (item) {
    return !!item;
  });

  var _scope2 = (scope2 || '').split(' ').filter(function (item) {
    return !!item;
  });

  if (!isScopeStrict && (!scope1 || !scope2)) {
    return true;
  } else if (isScopeStrict && !scope1 && !scope2) {
    return true;
  }

  var totalScope = _scope1.concat(_scope2);

  var uniqScope = _$5.uniq(totalScope);

  if (totalScope.length === uniqScope.length) {
    return false;
  } else {
    return true;
  }
});

var $$4 = require('jquery');

var _$6 = require('lodash');

var BaseGroup = /*#__PURE__*/function (_Group) {
  _inherits(BaseGroup, _Group);

  var _super = _createSuper(BaseGroup);

  function BaseGroup(opts) {
    var _this;

    _classCallCheck(this, BaseGroup);

    _this = _super.call(this, opts);
    _this.id = opts.id;
    _this.scope = opts.scope;
    _this.top = opts.top;
    _this.left = opts.left;
    _this.width = opts.width || 300;
    _this.height = opts.height || 150;
    _this.resize = opts.resize;
    _this.draggable = opts.draggable;
    _this.dom = null;
    _this.nodes = [];
    _this.options = opts.options; // 鸭子辨识手动判断类型

    _this.__type = 'group';
    _this._global = opts._global;
    _this._on = opts._on;
    _this._emit = opts._emit;
    _this._container = null; // endpoint 这部分需要考虑

    _this.endpoints = [];
    _this._endpointsData = opts.endpoints;
    return _this;
  }

  _createClass(BaseGroup, [{
    key: "init",
    value: function init() {
      this.dom = this.draw({
        id: this.id,
        top: this.top,
        left: this.left,
        width: this.width,
        height: this.height,
        dom: this.dom,
        options: this.options
      });

      this._addEventListener();
    }
  }, {
    key: "draw",
    value: function draw(obj) {
      var _dom = obj.dom;

      if (!_dom) {
        _dom = $$4('<div></div>').attr('class', 'group').attr('id', obj.id);
      }

      var group = $$4(_dom);
      var titleDom = $$4('<div></div>').attr('class', 'title');

      if (_$6.get(this, 'options.title')) {
        titleDom.text(_$6.get(this, 'options.title'));
      }

      group.append(titleDom);
      this._container = $$4('<div></div>').attr('class', 'container');
      group.append(this._container); // 默认resize打开

      if (this.resize !== false) {
        this.setResize(true, group);
      }

      if (obj.top !== undefined) {
        group.css('top', obj.top + 'px');
      }

      if (obj.left !== undefined) {
        group.css('left', obj.left + 'px');
      }

      if (obj.width !== undefined) {
        group.css('width', obj.width + 'px');
      }

      if (obj.height !== undefined) {
        group.css('height', obj.height + 'px');
      }

      this.updated && this.updated();
      return group[0];
    }
  }, {
    key: "addNodes",
    value: function addNodes() {
      var _this2 = this;

      var nodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var isNotEventEmit = arguments.length > 1 ? arguments[1] : undefined;
      nodes.forEach(function (item) {
        if (ScopeCompare(item.scope, _this2.scope, _$6.get(_this2, '_global.isScopeStrict'))) ; else {
          console.log("nodeId\u4E3A".concat(item.id, "\u7684\u8282\u70B9\u548CgroupId").concat(_this2.id, "\u7684\u8282\u70B9\u7EC4scope\u503C\u4E0D\u7B26\uFF0C\u65E0\u6CD5\u52A0\u5165"));
        }
      });
      this.emit('InnerEvents', {
        type: 'group:addNodes',
        nodes: nodes,
        group: this,
        isNotEventEmit: isNotEventEmit
      });
    }
  }, {
    key: "addNode",
    value: function addNode(node) {
      this.addNodes([node]);
    }
  }, {
    key: "removeNodes",
    value: function removeNodes() {
      var nodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var isNotEventEmit = arguments.length > 1 ? arguments[1] : undefined;
      var rmNodes = [];
      this.nodes.forEach(function (item) {
        var _node = _$6.find(nodes, function (_node) {
          return _node.id === item.id;
        });

        if (_node) {
          rmNodes.push(_node);
        }
      }); // this.nodes.forEach((item) => {
      //   let _node = _.find(nodes, (_node) => {
      //     return _node.id === item.id;
      //   });
      //   if (_node) {
      //     rmNodes.push(_node);
      //   }
      // });

      this.emit('InnerEvents', {
        type: 'group:removeNodes',
        group: this,
        nodes: rmNodes,
        isNotEventEmit: isNotEventEmit
      });

      if (!isNotEventEmit) {
        this.emit('events', _defineProperty({
          type: 'system.group.removeNodes',
          group: this,
          nodes: rmNodes
        }, "group", targetGroup));
        this.emit('system.group.removeNodes', _defineProperty({
          group: this,
          nodes: rmNodes
        }, "group", targetGroup));
      }

      return rmNodes;
    }
  }, {
    key: "removeNode",
    value: function removeNode(node) {
      return this.removeNodes([node]);
    }
  }, {
    key: "setResize",
    value: function setResize(flat) {
      var _this3 = this;

      var container = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.dom;
      var resizeDom = arguments.length > 2 ? arguments[2] : undefined;

      var mouseDown = function mouseDown(event) {
        var LEFT_KEY = 0;

        if (event.button !== LEFT_KEY) {
          return;
        }

        event.preventDefault(); // event.stopPropagation();

        _this3.emit('InnerEvents', {
          type: 'group:resize',
          group: _this3
        });
      };

      if (flat) {
        var icon = null;

        if (resizeDom) {
          icon = $$4(resizeDom);
          icon.addClass('butterfly-group-icon-resize');
        } else {
          icon = $$4('<span class="butterfly-group-icon-resize group-icon-resize butterfly-icon icon-drag"></span>');
        }

        icon.appendTo(container);
        icon.on('mousedown', mouseDown);
      }
    }
  }, {
    key: "setSize",
    value: function setSize() {
      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.width;
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.height;
      this.width = width;
      this.height = height;
      $$4(this.dom).css('width', this.width).css('height', this.height);
    }
  }, {
    key: "remove",
    value: function remove() {
      this.emit('InnerEvents', {
        type: 'group:delete',
        data: this
      });
    }
  }, {
    key: "_moveTo",
    value: function _moveTo(x, y) {
      var _this4 = this;

      // 自身移动
      $$4(this.dom).css('top', y).css('left', x); // 所在节点的锚点移动

      this.nodes.forEach(function (node) {
        node.endpoints.forEach(function (point) {
          point.updatePos();
        });
      }); // 节点组的锚点移动

      this.endpoints.forEach(function (item) {
        item.moveTo(x - _this4.left + item._left, y - _this4.top + item._top);
      });
      this.top = y;
      this.left = x;
    }
  }, {
    key: "moveTo",
    value: function moveTo(x, y, isNotEventEmit) {
      this.emit('InnerEvents', {
        type: 'group:move',
        group: this,
        x: x,
        y: y,
        isNotEventEmit: isNotEventEmit
      });
    }
  }, {
    key: "focus",
    value: function focus() {}
  }, {
    key: "unFocus",
    value: function unFocus() {}
  }, {
    key: "getWidth",
    value: function getWidth() {
      return this.width;
    }
  }, {
    key: "getHeight",
    value: function getHeight() {
      return this.height;
    }
  }, {
    key: "getEndpoint",
    value: function getEndpoint(pointId) {
      return _$6.find(this.endpoints, function (point) {
        return pointId === point.id;
      });
    }
  }, {
    key: "_appendNodes",
    value: function _appendNodes() {
      var _this5 = this;

      var nodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      nodes.forEach(function (item) {
        item._group = _this5;
        item.group = _this5.id;
        $$4(_this5.dom).append(item.dom);

        _this5.nodes.push(item);
      });
    }
  }, {
    key: "_addEventListener",
    value: function _addEventListener() {
      var _this6 = this;

      $$4(this.dom).on('click', function (e) {
        e.preventDefault();
        e.stopPropagation();

        _this6.emit('system.group.click', {
          group: _this6
        });

        _this6.emit('events', {
          type: 'group:click',
          group: _this6
        });
      });
      $$4(this.dom).on('mousedown', function (e) {
        // 兼容节点冒泡上来的事件
        var isChildNodeMoving = _$6.some(_this6.nodes, function (item) {
          return item._isMoving;
        });

        if (isChildNodeMoving) {
          return;
        } // 兼容resize按钮冒泡上来的事件


        if ($$4(e.target).attr('class').indexOf('butterfly-group-icon-resize') !== -1) {
          return;
        }

        var LEFT_KEY = 0;

        if (e.button !== LEFT_KEY) {
          return;
        }

        e.preventDefault(); // e.stopPropagation();

        if (_this6.draggable) {
          _this6.emit('InnerEvents', {
            type: 'group:dragBegin',
            data: _this6
          });
        }
      });
    }
  }, {
    key: "_createEndpoint",
    value: function _createEndpoint(isInited) {
      var _this7 = this;

      if (isInited) {
        this.endpoints.forEach(function (item) {
          return _this7.addEndpoint(item, isInited);
        });
      } else if (this._endpointsData) {
        this._endpointsData.map(function (item) {
          return _this7.addEndpoint(item);
        });
      }
    }
  }, {
    key: "addEndpoint",
    value: function addEndpoint(obj, isInited) {
      if (isInited) {
        this.emit('InnerEvents', {
          type: 'group:addEndpoint',
          data: obj,
          isInited: isInited
        });
        return obj;
      } // 这部分可能还需要想一下


      var EndpointClass = obj.Class || BaseEndpoint;
      var endpoint = new EndpointClass(_$6.assign({
        _on: this._on,
        _emit: this._emit,
        _node: this,
        _global: this._global
      }, obj));
      this.emit('InnerEvents', {
        type: 'group:addEndpoint',
        data: endpoint
      });
      this.endpoints.push(endpoint);
      return endpoint;
    }
  }, {
    key: "emit",
    value: function emit(type, data) {
      _get(_getPrototypeOf(BaseGroup.prototype), "emit", this).call(this, type, data);

      this._emit(type, data);
    }
  }, {
    key: "destroy",
    value: function destroy(isNotEventEmit) {
      this.endpoints.forEach(function (item) {
        !item._isInitedDom && item.destroy();
      });
      $$4(this.dom).off();
      $$4(this.dom).remove();

      if (!isNotEventEmit) {
        this._emit('system.group.delete', {
          group: this
        });

        this._emit('events', {
          type: 'group:delete',
          group: this
        });

        this.removeAllListeners();
      }
    }
  }]);

  return BaseGroup;
}(Group);

function circleLayout(params) {
  var radius = params.radius;
  var nodes = params.data.nodes.filter(function (node) {
    return node._isCircle;
  });

  var _preAngle = 360 / nodes.length;

  var _halfWidth = 0;

  if (params.getWidth) {
    _halfWidth = params.getWidth() / 2;
  }

  var _halfHeight = 0;

  if (params.getHeight) {
    _halfWidth = params.getHeight() / 2;
  }

  nodes.forEach(function (item, index) {
    var radian = 2 * Math.PI / 360;
    var angle = index * _preAngle;

    var _top = radius * Math.sin(angle * radian) - _halfHeight;

    var _left = radius * Math.cos(angle * radian) - _halfWidth;

    var _textTop = (radius + 30) * Math.sin(angle * radian) - _halfHeight;

    var _textLeft = (radius + 30) * Math.cos(angle * radian) - _halfWidth;

    item.top = _top;
    item.left = _left;
    item.posInfo = {
      angle: angle,
      _textTop: _textTop,
      _textLeft: _textLeft
    };
  });
} // module.exports = circleLayout;


var Layout = {
  circleLayout: circleLayout
};

var SPEED_DIVISOR = 800;

function fruchterman(param) {
  var self = param.opts;
  var nodes = param.data.nodes;
  var center = self.center;

  if (!nodes || nodes.length === 0) {
    return;
  }

  if (nodes.length === 1) {
    nodes[0].x = center[0];
    nodes[0].y = center[1];
    return;
  }

  var nodeMap = {};
  var nodeIdxMap = {};
  nodes.forEach(function (node, i) {
    if (!_.isNumber(node.x)) node.x = Math.random() * self.width;
    if (!_.isNumber(node.y)) node.y = Math.random() * self.height;
    nodeMap[node.id] = node;
    nodeIdxMap[node.id] = i;
  });
  self.nodeMap = nodeMap;
  self.nodeIdxMap = nodeIdxMap; // layout

  run(param);
}

function run(param) {
  var self = param.opts;
  var nodes = param.data.nodes;
  var edges = param.data.edges;
  var maxIteration = self.maxIteration;

  if (!self.width && typeof window !== 'undefined') {
    self.width = window.innerWidth;
  }

  if (!self.height && typeof window !== 'undefined') {
    self.height = window.innerHeight;
  }

  var center = self.center;
  var maxDisplace = self.width / 10;
  var k = Math.sqrt(self.width * self.height / (nodes.length + 1));
  var gravity = self.gravity;
  var speed = self.speed;
  var clustering = self.clustering;
  var clusterMap = {};

  if (clustering) {
    nodes.forEach(function (n) {
      if (clusterMap[n.cluster] === undefined) {
        var cluster = {
          name: n.cluster,
          cx: 0,
          cy: 0,
          count: 0
        };
        clusterMap[n.cluster] = cluster;
      }

      var c = clusterMap[n.cluster];

      if (_.isNumber(n.x)) {
        c.cx += n.x;
      }

      if (_.isNumber(n.y)) {
        c.cy += n.y;
      }

      c.count++;
    });

    for (var key in clusterMap) {
      clusterMap[key].cx /= clusterMap[key].count;
      clusterMap[key].cy /= clusterMap[key].count;
    }
  }

  var _loop = function _loop(i) {
    var displacements = [];
    nodes.forEach(function (_, j) {
      displacements[j] = {
        x: 0,
        y: 0
      };
    });
    applyCalculate(nodes, edges, displacements, k, self); // gravity for clusters

    if (clustering) {
      var clusterGravity = self.clusterGravity || gravity;
      nodes.forEach(function (n, j) {
        if (!_.isNumber(n.x) || !_.isNumber(n.y)) return;
        var c = clusterMap[n.cluster];
        var distLength = Math.sqrt((n.x - c.cx) * (n.x - c.cx) + (n.y - c.cy) * (n.y - c.cy));
        var gravityForce = k * clusterGravity;
        displacements[j].x -= gravityForce * (n.x - c.cx) / distLength;
        displacements[j].y -= gravityForce * (n.y - c.cy) / distLength;
      });

      for (var _key in clusterMap) {
        clusterMap[_key].cx = 0;
        clusterMap[_key].cy = 0;
        clusterMap[_key].count = 0;
      }

      nodes.forEach(function (n) {
        var c = clusterMap[n.cluster];

        if (_.isNumber(n.x)) {
          c.cx += n.x;
        }

        if (_.isNumber(n.y)) {
          c.cy += n.y;
        }

        c.count++;
      });

      for (var _key2 in clusterMap) {
        clusterMap[_key2].cx /= clusterMap[_key2].count;
        clusterMap[_key2].cy /= clusterMap[_key2].count;
      }
    } // gravity


    nodes.forEach(function (n, j) {
      if (!_.isNumber(n.x) || !_.isNumber(n.y)) return;
      var gravityForce = 0.01 * k * gravity;
      displacements[j].x -= gravityForce * (n.x - center[0]);
      displacements[j].y -= gravityForce * (n.y - center[1]);
    }); // move

    nodes.forEach(function (n, j) {
      if (!_.isNumber(n.x) || !_.isNumber(n.y)) return;
      var distLength = Math.sqrt(displacements[j].x * displacements[j].x + displacements[j].y * displacements[j].y);

      if (distLength > 0) {
        // && !n.isFixed()
        var limitedDist = Math.min(maxDisplace * (speed / SPEED_DIVISOR), distLength);
        n.x += displacements[j].x / distLength * limitedDist;
        n.y += displacements[j].y / distLength * limitedDist;
      }
    });
  };

  for (var i = 0; i < maxIteration; i++) {
    _loop();
  }
}

function applyCalculate(nodes, edges, displacements, k, self) {
  calRepulsive(nodes, displacements, k);
  calAttractive(edges, displacements, k, self);
}

function calRepulsive(nodes, displacements, k) {
  nodes.forEach(function (v, i) {
    displacements[i] = {
      x: 0,
      y: 0
    };
    nodes.forEach(function (u, j) {
      if (i === j) {
        return;
      }

      if (!_.isNumber(v.x) || !_.isNumber(u.x) || !_.isNumber(v.y) || !_.isNumber(u.y)) return;
      var vecX = v.x - u.x;
      var vecY = v.y - u.y;
      var vecLengthSqr = vecX * vecX + vecY * vecY;

      if (vecLengthSqr === 0) {
        vecLengthSqr = 1;
        var sign = i > j ? 1 : -1;
        vecX = 0.01 * sign;
        vecY = 0.01 * sign;
      }

      var common = k * k / vecLengthSqr;
      displacements[i].x += vecX * common;
      displacements[i].y += vecY * common;
    });
  });
}

function calAttractive(edges, displacements, k, self) {
  edges.forEach(function (e) {
    if (!e.source || !e.target) return;
    var uIndex = self.nodeIdxMap[e.source];
    var vIndex = self.nodeIdxMap[e.target];

    if (uIndex === vIndex) {
      return;
    }

    var u = self.nodeMap[e.source];
    var v = self.nodeMap[e.target];
    if (!_.isNumber(v.x) || !_.isNumber(u.x) || !_.isNumber(v.y) || !_.isNumber(u.y)) return;
    var vecX = v.x - u.x;
    var vecY = v.y - u.y;
    var vecLength = Math.sqrt(vecX * vecX + vecY * vecY);
    var common = vecLength * vecLength / k;
    displacements[vIndex].x -= vecX / vecLength * common;
    displacements[vIndex].y -= vecY / vecLength * common;
    displacements[uIndex].x += vecX / vecLength * common;
    displacements[uIndex].y += vecY / vecLength * common;
  });
}

var fruchterman_1 = fruchterman; //   export default {

function gridLayout(param) {
  var self = param.opts;
  var nodes = param.data.nodes;
  var n = nodes.length;
  var center = self.center;

  if (n === 0) {
    return;
  }

  if (n === 1) {
    nodes[0].x = center[0];
    nodes[0].y = center[1];
    return;
  }

  var edges = param.data.edges;
  var layoutNodes = [];
  nodes.forEach(function (node) {
    layoutNodes.push(node);
  });
  var nodeIdxMap = {};
  layoutNodes.forEach(function (node, i) {
    nodeIdxMap[node.id] = i;
  }); // 排序

  if (self.sortBy === 'degree' || typeof self.sortBy === 'string' || layoutNodes[0][self.sortBy] === undefined) {
    self.sortBy = 'degree';

    if (isNaN(nodes[0].degree)) {
      var values = getDegree(layoutNodes.length, nodeIdxMap, edges);
      layoutNodes.forEach(function (node, i) {
        node.degree = values[i];
      });
    }
  } // sort nodes by value


  layoutNodes.sort(function (n1, n2) {
    return n2[self.sortBy] - n1[self.sortBy];
  });

  if (!self.width && typeof window !== 'undefined') {
    self.width = window.innerWidth;
  }

  if (!self.height && typeof window !== 'undefined') {
    self.height = window.innerHeight;
  }

  var oRows = self.rows;
  var oCols = self.cols != null ? self.cols : self.columns;
  self.cells = n; // if rows or columns were set in self, use those values

  if (oRows != null && oCols != null) {
    self.rows = oRows;
    self.cols = oCols;
  } else if (oRows != null && oCols == null) {
    self.rows = oRows;
    self.cols = Math.ceil(self.cells / self.rows);
  } else if (oRows == null && oCols != null) {
    self.cols = oCols;
    self.rows = Math.ceil(self.cells / self.cols);
  } else {
    // otherwise use the automatic values and adjust accordingly	      // otherwise use the automatic values and adjust accordingly
    // width/height * splits^2 = cells where splits is number of times to split width
    self.splits = Math.sqrt(self.cells * self.height / self.width);
    self.rows = Math.round(self.splits);
    self.cols = Math.round(self.width / self.height * self.splits);
  }

  self.cellWidth = self.width / self.cols;
  self.cellHeight = self.height / self.rows;

  if (self.condense) {
    self.cellWidth = 0;
    self.cellHeight = 0;
  }

  if (self.preventOverlap) {
    layoutNodes.forEach(function (node) {
      if (!node.x || !node.y) {
        // for bb
        node.x = 0;
        node.y = 0;
      }

      var nodew;
      var nodeh; // if (isArray(node.size)) {
      //   nodew = node.size[0];
      //   nodeh = node.size[1];
      // } else 

      if (typeof node.size === 'number') {
        nodew = node.size;
        nodeh = node.size;
      }

      if (nodew === undefined || nodeh === undefined) {
        // if (isArray(self.nodeSize)) {
        //   nodew = self.nodeSize[0];
        //   nodeh = self.nodeSize[1];
        // } else 
        if (typeof node.nodeSize === 'number') {
          nodew = self.nodeSize;
          nodeh = self.nodeSize;
        } else {
          nodew = 30;
          nodeh = 30;
        }
      }

      var p = self.preventOverlapPadding;
      var w = nodew + p;
      var h = nodeh + p;
      self.cellWidth = Math.max(self.cellWidth, w);
      self.cellHeight = Math.max(self.cellHeight, h);
    });
  }

  self.cellUsed = {}; // e.g. 'c-0-2' => true
  // to keep track of current cell position

  self.row = 0;
  self.col = 0; // get a cache of all the manual positions

  self.id2manPos = {};

  for (var i = 0; i < layoutNodes.length; i++) {
    var node = layoutNodes[i];
    var rcPos = void 0;

    if (self.position) {
      rcPos = self.position(node);
    }

    if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {
      // must have at least row or col def'd
      var pos = {
        row: rcPos.row,
        col: rcPos.col
      };

      if (pos.col === undefined) {
        // find unused col
        pos.col = 0;

        while (used(pos.row, pos.col, self)) {
          pos.col++;
        }
      } else if (pos.row === undefined) {
        // find unused row
        pos.row = 0;

        while (used(pos.row, pos.col, self)) {
          pos.row++;
        }
      }

      self.id2manPos[node.id] = pos;
      use(pos.row, pos.col);
    }

    getPos(node, self);
  }
}

function getDegree(n, nodeIdxMap, edges) {
  var degrees = [];

  for (var i = 0; i < n; i++) {
    degrees[i] = 0;
  }

  edges.forEach(function (e) {
    if (e.source) {
      degrees[nodeIdxMap[e.source]] += 1;
    }

    if (e.target) {
      degrees[nodeIdxMap[e.target]] += 1;
    }
  });
  return degrees;
}

function use(row, col, self) {
  self.cellUsed["c-".concat(row, "-").concat(col)] = true;
}

function used(row, col, self) {
  return self.cellUsed["c-".concat(row, "-").concat(col)] || false;
}

function moveToNextCell(param) {
  var self = param;
  var cols = self.cols || 5;
  self.col++;

  if (self.col >= cols) {
    self.col = 0;
    self.row++;
  }
}

function getPos(node, param) {
  var self = param;
  var begin = self.begin;
  var cellWidth = self.width;
  var cellHeight = self.height;
  var x;
  var y; // see if we have a manual position set

  var rcPos = self.id2manPos[node.id];

  if (rcPos) {
    x = rcPos.col * cellWidth + cellWidth / 2 + begin[0];
    y = rcPos.row * cellHeight + cellHeight / 2 + begin[1];
  } else {
    // otherwise set automatically
    while (used(self.row, self.col, self)) {
      moveToNextCell(param);
    }

    x = self.col * cellWidth + cellWidth / 2 + begin[0];
    y = self.row * cellHeight + cellHeight / 2 + begin[1];
    use(self.row, self.col, self);
    moveToNextCell(param);
  }

  node.x = x;
  node.y = y;
  node.left = x;
  node.top = y;
}

var gridLayout_1 = gridLayout;

// 离散布局


function forceLayout(param) {
  var opts = param.opts;

  var data = _.cloneDeep(param.data); // 处理groups的布局,把group当成一个节点


  var nodes = data.nodes.filter(function (item) {
    return !item.group;
  });
  var groupNodes = data.nodes.filter(function (item) {
    return item.group;
  });
  nodes = nodes.concat(data.groups); // 在group内先random布局一下

  groupNodes.forEach(function (item) {
    var group = _.find(data.groups, function (_group) {
      return _group.id === item.group;
    });

    item.x = Math.random() * (group.width || 150);
    item.y = Math.random() * (group.height || 120);
  });
  var edges = data.edges.map(function (_edge) {
    var souceNode = _.find(groupNodes, function (_node) {
      return _node.source === _edge.id;
    });

    if (souceNode) {
      _edge.source = souceNode.group;
    }

    var targetNode = _.find(groupNodes, function (_node) {
      return _node.target === _edge.id;
    });

    if (targetNode) {
      _edge.target = souceNode.group;
    }

    return _edge;
  });
  var simulation = d3Force.forceSimulation(nodes).force('charge', function () {
    if (opts.chargeStrength) {
      return d3Force.forceManyBody().strength(opts.chargeStrength);
    } else {
      return d3Force.forceManyBody();
    }
  }()).force('center', d3Force.forceCenter(opts.width / 2, opts.height / 2)).force('link', d3Force.forceLink(edges).id(function (node) {
    return node[_.get(opts.link, 'id', 'id')];
  }).distance(opts.link.distance).strength(opts.link.strength)).stop();

  for (var i = 0, n = Math.ceil(Math.log(simulation.alphaMin()) / Math.log(1 - simulation.alphaDecay())); i < n; ++i) {
    simulation.tick();
  }

  param.data.nodes.forEach(function (node, index) {
    node.top = data.nodes[index].y;
    node.left = data.nodes[index].x;
  });
  param.data.groups.forEach(function (group, index) {
    group.top = data.groups[index].y;
    group.left = data.groups[index].x;
  }); // 后续需要考虑group的布局
}

var forceLayout_1 = forceLayout;

// 同心圆布局
function concentLayout(param) {
  var center = param.center,
      nodeSize = param.nodeSize,
      minNodeSpacing = param.minNodeSpacing,
      preventOverlap = param.preventOverlap,
      sweep = param.sweep,
      equidistant = param.equidistant,
      _param$startAngle = param.startAngle,
      startAngle = _param$startAngle === void 0 ? 3 / 2 * Math.PI : _param$startAngle,
      clockwise = param.clockwise,
      maxLevelDiff = param.maxLevelDiff,
      sortBy = param.sortBy,
      width = param.width,
      height = param.height,
      data = param.data;
  var curnode = data.nodes;
  var curedges = data.edges;
  var nodes = curnode.map(function (item) {
    return {
      id: item.id,
      top: item.top,
      left: item.left,
      degree: item.degree,
      size: item.size
    };
  });
  var edges = curedges.map(function (item) {
    return {
      source: item.source,
      target: item.target
    };
  });
  var n = nodes.length;
  var maxValueNode;

  if (n === 0) {
    return;
  }

  if (n === 1) {
    nodes[0].x = center[0];
    nodes[0].y = center[1];
    return;
  }

  var layoutNodes = [];
  var maxNodeSize;

  if (_.isArray(nodeSize)) {
    maxNodeSize = Math.max(nodeSize[0], nodeSize[1]);
  } else {
    maxNodeSize = nodeSize;
  }

  nodes.forEach(function (node) {
    layoutNodes.push(node);
    var nodeSize = maxNodeSize;

    if (_.isArray(node.size)) {
      nodeSize = Math.max(node.size[0], node.size[1]);
    } else if (_.isNumber(node.size)) {
      nodeSize = node.size;
    }

    maxNodeSize = Math.max(maxNodeSize, nodeSize);
  });

  if (!width && typeof window !== 'undefined') {
    width = window.innerWidth;
  }

  if (!height && typeof window !== 'undefined') {
    height = window.innerHeight;
  }

  clockwise =  clockwise; // layout

  var nodeMap = {};
  var nodeIdxMap = {};
  layoutNodes.forEach(function (node, i) {
    nodeMap[node.id] = node;
    nodeIdxMap[node.id] = i;
  }); // get the node degrees

  if (sortBy === 'degree' || !_.isString(sortBy) || layoutNodes[0][sortBy] === undefined) {
    sortBy = 'degree';

    if (!_.isNumber(nodes[0].degree)) {
      var values = [];
      var len = nodes.length;

      for (var i = 0; i < len; i++) {
        values[i] = 0;
      }

      edges.forEach(function (e) {
        if (e.source) {
          values[nodeIdxMap[e.source]] += 1;
        }

        if (e.target) {
          values[nodeIdxMap[e.target]] += 1;
        }
      });
      layoutNodes.forEach(function (node, i) {
        node.degree = values[i];
      });
    }
  } // sort nodes by value


  layoutNodes.sort(function (n1, n2) {
    return n2[sortBy] - n1[sortBy];
  });
  maxValueNode = layoutNodes[0];
  maxLevelDiff = maxLevelDiff || maxValueNode[sortBy] / 4; // put the values into levels

  var levels = [[]];
  var currentLevel = levels[0];
  layoutNodes.forEach(function (node) {
    if (currentLevel.length > 0) {
      var diff = Math.abs(currentLevel[0][sortBy] - node[sortBy]);

      if (maxLevelDiff && diff >= maxLevelDiff) {
        currentLevel = [];
        levels.push(currentLevel);
      }
    }

    currentLevel.push(node);
  }); // create positions for levels

  var minDist = maxNodeSize + minNodeSpacing; // min dist between nodes

  if (!preventOverlap) {
    // then strictly constrain to bb
    var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;
    var maxR = Math.min(width, height) / 2 - minDist;
    var rStep = maxR / (levels.length + (firstLvlHasMulti ? 1 : 0));
    minDist = Math.min(minDist, rStep);
  } // find the metrics for each level


  var r = 0;
  levels.forEach(function (level) {
    var sweep = sweep;

    if (sweep === undefined) {
      sweep = 2 * Math.PI - 2 * Math.PI / level.length;
    }

    var dTheta = level.dTheta = sweep / Math.max(1, level.length - 1); // calculate the radius

    if (level.length > 1 && preventOverlap) {
      // but only if more than one node (can't overlap)
      var dcos = Math.cos(dTheta) - Math.cos(0);
      var dsin = Math.sin(dTheta) - Math.sin(0);
      var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping

      r = Math.max(rMin, r);
    }

    level.r = r;
    r += minDist;
  });

  if (equidistant) {
    var rDeltaMax = 0;
    var rr = 0;

    for (var _i = 0; _i < levels.length; _i++) {
      var level = levels[_i];
      var rDelta = level.r - rr;
      rDeltaMax = Math.max(rDeltaMax, rDelta);
    }

    rr = 0;
    levels.forEach(function (level, i) {
      if (i === 0) {
        rr = level.r;
      }

      level.r = rr;
      rr += rDeltaMax;
    });
  } // calculate the node positions


  levels.forEach(function (level) {
    var dTheta = level.dTheta;
    var rr = level.r;
    level.forEach(function (node, j) {
      var theta = startAngle + (clockwise ? 1 : -1) * dTheta * j;
      node.x = center[0] + rr * Math.cos(theta);
      node.y = center[1] + rr * Math.sin(theta);
    });
  });
  param.data.nodes.forEach(function (node, index) {
    node.top = nodes[index].y;
    node.left = nodes[index].x;
  });
}

var concentLayout_1 = concentLayout;

//drage布局


function drageLayout(param) {
  var nodeSize = param.nodeSize,
      rankdir = param.rankdir,
      nodesepFunc = param.nodesepFunc,
      ranksepFunc = param.ranksepFunc,
      nodesep = param.nodesep,
      ranksep = param.ranksep,
      controlPoints = param.controlPoints;
  var _param$data$edges = param.data.edges,
      edges = _param$data$edges === void 0 ? [] : _param$data$edges;
  var curnode = param.data.nodes;
  var nodes = curnode.map(function (item) {
    return {
      id: item.id,
      top: item.top,
      left: item.left
    };
  }); // 形成新数组后布局失效

  if (!nodes) return;
  var g = new dagre.graphlib.Graph();
  var nodeSizeFunc;

  if (!nodeSize) {
    nodeSizeFunc = function nodeSizeFunc(d) {
      if (d.size) {
        if (_.isArray(d.size)) {
          return d.size;
        }

        return [d.size, d.size];
      }

      return [40, 40];
    };
  } else if (_.isArray(nodeSize)) {
    nodeSizeFunc = function nodeSizeFunc() {
      return nodeSize;
    };
  } else {
    nodeSizeFunc = function nodeSizeFunc() {
      return [nodeSize, nodeSize];
    };
  }

  var horisep = getFunc(nodesepFunc, nodesep, 50);
  var vertisep = getFunc(ranksepFunc, ranksep, 50);

  if (rankdir === 'LR' || rankdir === 'RL') {
    horisep = getFunc(ranksepFunc, ranksep, 50);
    vertisep = getFunc(nodesepFunc, nodesep, 50);
  }

  nodes.forEach(function (node) {
    var size = nodeSizeFunc(node);
    var verti = vertisep(node);
    var hori = horisep(node);
    var width = size[0] + 2 * hori;
    var height = size[1] + 2 * verti;
    g.setNode(node.id, {
      width: width,
      height: height
    });
  });
  edges.forEach(function (edge) {
    // dagrejs Wiki https://github.com/dagrejs/dagre/wiki#configuring-the-layout
    g.setEdge(edge.source, edge.target, {
      weight: edge.weight || 1
    });
  });
  g.setDefaultEdgeLabel(function () {
    return {};
  });
  param.nodes = nodes;
  g.setGraph(param);
  dagre.layout(g);
  var coord; // 重新布局时g.nodes()可能为undefined

  g.nodes().forEach(function (node) {
    coord = g.node(node);

    if (coord) {
      var i = nodes.findIndex(function (it) {
        return it.id === node;
      });
      nodes[i].left = coord.x;
      nodes[i].top = coord.y;
      nodes[i].posInfo = {
        _out: g._out[node],
        _in: g._in[node],
        _preds: g._preds[node],
        _sucs: g._sucs[node]
      };
    }
  });
  g.edges().forEach(function (edge) {
    coord = g.edge(edge);
    var i = edges.findIndex(function (it) {
      return it.source === edge.v && it.target === edge.w;
    });

    if (controlPoints && edges[i].type !== 'loop' && edges[i].shape !== 'loop') {
      edges[i].controlPoints = coord.points.slice(1, coord.points.length - 1);
    }
  }); // 将数据挂载到原有数据上，以触发布局

  nodes.forEach(function (item, index) {
    curnode[index].left = item.left;
    curnode[index].top = item.top;
    curnode[index].posInfo = item.posInfo;
  });
}

function getFunc(func, value, defaultValue) {
  var resultFunc;

  if (func) {
    resultFunc = func;
  } else if (_.isNumber(value)) {
    resultFunc = function resultFunc() {
      return value;
    };
  } else {
    resultFunc = function resultFunc() {
      return defaultValue;
    };
  }

  return resultFunc;
}

var drageLayout_1 = drageLayout;

var d3 = require('d3-force');

var _$7 = require('lodash');

function forceTreeLayout(param) {
  var opts = param.opts;

  var data = _$7.cloneDeep(param.data);

  var simulation = d3.forceSimulation(data.nodes) // d3.forceLink(links).distance(20).strength(1)
  .force('charge', d3.forceManyBody().strength(opts.chargeStrength)).force('center', d3.forceCenter(opts.width / 2, opts.height / 2)).force('link', d3.forceLink(data.edges).distance(opts.link.distance).strength(opts.link.strength)).force('x', d3.forceX()).force('y', d3.forceY()).stop();

  for (var i = 0, n = Math.ceil(Math.log(simulation.alphaMin()) / Math.log(1 - simulation.alphaDecay())); i < n; ++i) {
    simulation.tick();
  }

  param.data.nodes.forEach(function (node, index) {
    node.top = data.nodes[index].y;
    node.left = data.nodes[index].x;
  }); // 后续需要考虑group的布局
} // 后续拓展树形布局


function treeLayout(param) {}

var Layout$1 = {
  forceLayout: forceLayout_1,
  forceTreeLayout: forceTreeLayout,
  treeLayout: treeLayout,
  drageLayout: drageLayout_1,
  concentLayout: concentLayout_1,
  gridLayout: gridLayout_1,
  fruchterman: fruchterman_1,
  circleLayout: Layout.circleLayout
};

var $$5 = require('jquery');

var SelectCanvas = /*#__PURE__*/function () {
  function SelectCanvas() {
    _classCallCheck(this, SelectCanvas);

    this.dom = $$5('<canvas class="butterfly-selected-canvas"></canvas>')[0];
    this.cxt = this.dom.getContext('2d');
    this.canvasTop = 0;
    this.canvasLeft = 0;
    this.canvasHeight = 0;
    this.canvasWidth = 0;
    this.canScrollX = 0;
    this.canScrollY = 0;
    this.startX = 0;
    this.startY = 0;
    this.endX = 0;
    this.endY = 0;
    this._on = null;
    this._emit = null;
    this.isDraw = false;
    this.isActive = false;
  }

  _createClass(SelectCanvas, [{
    key: "init",
    value: function init(opts) {
      var root = opts.root;
      var offset = $$5(root).offset();
      this.canvasTop = offset.top;
      this.canvasLeft = offset.left;
      this.canvasHeight = $$5(root).height();
      this.canvasWidth = $$5(root).width();
      this._on = opts._on;
      this._emit = opts._emit;
      $$5(this.dom).attr('width', this.canvasWidth);
      $$5(this.dom).attr('height', this.canvasHeight);
      this.addEventListener();
      $$5(this.dom).appendTo(root);
    }
  }, {
    key: "resize",
    value: function resize(opts) {
      var root = opts.root;
      var offset = $$5(root).offset();
      this.canvasTop = offset.top;
      this.canvasLeft = offset.left;
      this.canvasHeight = $$5(root).height();
      this.canvasWidth = $$5(root).width();
      $$5(this.dom).attr('width', this.canvasWidth);
      $$5(this.dom).attr('height', this.canvasHeight);
    }
  }, {
    key: "addEventListener",
    value: function addEventListener() {
      this.dom.addEventListener('mousedown', this.mouseDown.bind(this));
      this.dom.addEventListener('mouseup', this.mouseUp.bind(this));
      this.dom.addEventListener('mousemove', this.mouseMove.bind(this));
      this.dom.addEventListener('mouseleave', this.mouseLeave.bind(this));
    }
  }, {
    key: "mouseDown",
    value: function mouseDown(evt) {
      this.startX = evt.clientX;
      this.startY = evt.clientY;
      this.isDraw = true;
    }
  }, {
    key: "mouseUp",
    value: function mouseUp(evt) {
      this.isDraw = false;
      this.clearCanvas();
      var startX = this.startX;
      var startY = this.startY;
      var endX = this.endX = evt.clientX;
      var endY = this.endY = evt.clientY;
      var toDirection = endX - startX > 0 ? 'right' : 'left';
      var startLeft = startX > endX ? endX : startX;
      var startTop = startY > endY ? endY : startY;
      var endLeft = startX > endX ? startX : endX;
      var endTop = startY > endY ? startY : endY;

      this._emit('InnerEvents', {
        type: 'multiple:select',
        range: [startLeft, startTop, endLeft, endTop],
        toDirection: toDirection
      });

      this.unActive();
    }
  }, {
    key: "mouseMove",
    value: function mouseMove(evt) {
      if (!this.isDraw) {
        return;
      }

      this.endX = evt.clientX;
      this.endY = evt.clientY;
      this.drawRect();
    }
  }, {
    key: "mouseLeave",
    value: function mouseLeave(evt) {
      this.isDraw = false;
      this.clearCanvas();
    }
  }, {
    key: "drawRect",
    value: function drawRect() {
      if (!this.isDraw) {
        return;
      }

      this.clearCanvas();
      var startX = Math.min(this.startX, this.endX) - this.canvasLeft + this.canScrollX;
      var startY = Math.min(this.startY, this.endY) - this.canvasTop + this.canScrollY;
      var width = Math.abs(this.startX - this.endX);
      var height = Math.abs(this.startY - this.endY);
      this.cxt.beginPath();
      this.cxt.rect(startX, startY, width, height);
      this.cxt.fillStyle = '#b3dbff';
      this.cxt.fill();
      this.cxt.lineWidth = '1';
      this.cxt.strokeStyle = '#3da4ff';
      this.cxt.stroke();
    }
  }, {
    key: "clearCanvas",
    value: function clearCanvas() {
      this.cxt.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
    }
  }, {
    key: "getCanvas",
    value: function getCanvas() {
      return this.dom;
    }
  }, {
    key: "active",
    value: function active() {
      if (!this.isActive) {
        $$5(this.dom).addClass('wrapper-up');
        this.isActive = true;
      }
    }
  }, {
    key: "unActive",
    value: function unActive() {
      if (this.isActive) {
        $$5(this.dom).removeClass('wrapper-up');
        this.isActive = false;
      }
    }
  }, {
    key: "_changeCanvasInfo",
    value: function _changeCanvasInfo(data) {
      if (data.terScrollX !== undefined) {
        this.canScrollX = data.terScrollX;
      }

      if (data.terScrollY !== undefined) {
        this.canScrollY = data.terScrollY;
      }
    }
  }]);

  return SelectCanvas;
}();

var _$8 = require('lodash');

var CoordinateService = /*#__PURE__*/function () {
  function CoordinateService(opts) {
    _classCallCheck(this, CoordinateService);

    this.canvas = opts.canvas;
    this.terOffsetX = opts.terOffsetX || 0;
    this.terOffsetY = opts.terOffsetY || 0;
    this.terWidth = opts.terWidth || 0;
    this.terHeight = opts.terHeight || 0;
    this.canOffsetX = opts.canOffsetX || 0;
    this.canOffsetY = opts.canOffsetY || 0;
    this.scale = opts.scale || 1; // 中心点

    this.originX = undefined;
    this.originY = undefined; // 当前鼠标在容器内的坐标

    this._currentTerX = 0;
    this._currentTerY = 0;
  }

  _createClass(CoordinateService, [{
    key: "_changeCanvasInfo",
    value: function _changeCanvasInfo(data) {
      if (data.terOffsetX !== undefined) {
        this.terOffsetX = data.terOffsetX;
      }

      if (data.terOffsetY !== undefined) {
        this.terOffsetY = data.terOffsetY;
      }

      if (data.terWidth !== undefined) {
        this.terWidth = data.terWidth;
      }

      if (data.terHeight !== undefined) {
        this.terHeight = data.terHeight;
      }

      if (data.canOffsetX !== undefined) {
        this.canOffsetX = data.canOffsetX;
      }

      if (data.canOffsetY !== undefined) {
        this.canOffsetY = data.canOffsetY;
      }

      if (data.scale !== undefined) {
        this._lastScale = this.scale;
        this.scale = data.scale;
      }

      if (data.canvas) {
        this.canvas = data.canvas;
      }

      var _isChangeOrigin = false;

      if (data.originX !== undefined) {
        this.originX = data.originX;
        _isChangeOrigin = true;
      }

      if (data.originY !== undefined) {
        this.originY = data.originY;
        _isChangeOrigin = true;
      }

      if (_isChangeOrigin) {
        this.canvas.wrapper.style.transformOrigin = "".concat(this.originX, "% ").concat(this.originY, "%");
      }

      var _isChangeMouse = false;

      if (data.mouseX !== undefined) {
        if (this._currentTerX !== data.mouseX - this.terOffsetX) {
          this._currentTerX = data.mouseX - this.terOffsetX;
          _isChangeMouse = true;
        }
      }

      if (data.mouseY !== undefined) {
        if (this._currentTerY !== data.mouseY - this.terOffsetY) {
          this._currentTerY = data.mouseY - this.terOffsetY;
          _isChangeMouse = true;
        }
      }

      if (_isChangeMouse) {
        if (this.originX === undefined || this.originY === undefined) {
          this.originX = 0;
          this.originY = 0;
        } // i,j


        var i = this.originX / 100 * this.terWidth;
        var j = this.originY / 100 * this.terHeight;
        var oldOffset = [parseInt(this.canOffsetX), parseInt(this.canOffsetY)];

        var _localtionX = (data.mouseX - (i * (1 - this._lastScale) + oldOffset[0]) - this.terOffsetX) / this._lastScale;

        var _localtionY = (data.mouseY - (j * (1 - this._lastScale) + oldOffset[1]) - this.terOffsetY) / this._lastScale;

        var newOriginX = _localtionX / this.terWidth * 100;
        var newOriginY = _localtionY / this.terHeight * 100;
        var e = -i * (1 - this._lastScale);
        var f = -j * (1 - this._lastScale);
        i = newOriginX / 100 * this.terWidth;
        j = newOriginY / 100 * this.terHeight;
        var g = -i * (1 - this._lastScale);
        var h = -j * (1 - this._lastScale);

        var _newLeft = g - e + oldOffset[0];

        var _newTop = h - f + oldOffset[1];

        this.canvas.wrapper.style.transformOrigin = "".concat(newOriginX, "% ").concat(newOriginY, "%");
        this.canvas.move([_newLeft, _newTop]);
        this.originX = newOriginX;
        this.originY = newOriginY;
      }
    }
  }, {
    key: "canvas2terminal",
    value: function canvas2terminal(coordinates, options) {
      return [this._canvas2terminal('x', coordinates[0], options), this._canvas2terminal('y', coordinates[1], options)];
    }
  }, {
    key: "terminal2canvas",
    value: function terminal2canvas(coordinates, options) {
      return [this._terminal2canvas('x', coordinates[0], options), this._terminal2canvas('y', coordinates[1], options)];
    }
  }, {
    key: "_canvas2terminal",
    value: function _canvas2terminal(pos, coordinate, options) {
      var scale = _$8.get(options, 'scale') || this.scale;
      var canOffsetX = _$8.get(options, 'canOffsetX') !== undefined ? _$8.get(options, 'canOffsetX') : this.canOffsetX;
      var canOffsetY = _$8.get(options, 'canOffsetY') !== undefined ? _$8.get(options, 'canOffsetY') : this.canOffsetY;
      var terOffsetX = _$8.get(options, 'terOffsetX') !== undefined ? _$8.get(options, 'terOffsetX') : this.terOffsetX;
      var terOffsetY = _$8.get(options, 'terOffsetY') !== undefined ? _$8.get(options, 'terOffsetY') : this.terOffsetY;
      var originX = _$8.get(options, 'originX') !== undefined ? _$8.get(options, 'originX') : this.originX || 0;
      var originY = _$8.get(options, 'originY') !== undefined ? _$8.get(options, 'originY') : this.originY || 0;

      if (pos === 'x') {
        var transformOriginX = originX / 100 * this.terWidth;
        return coordinate * scale + (transformOriginX * (1 - scale) + canOffsetX) + terOffsetX;
      }

      if (pos === 'y') {
        var transformOriginY = originY / 100 * this.terHeight;
        return coordinate * scale + (transformOriginY * (1 - scale) + canOffsetY) + terOffsetY;
      }
    }
  }, {
    key: "_terminal2canvas",
    value: function _terminal2canvas(pos, coordinate, options) {
      var scale = _$8.get(options, 'scale') || this.scale;
      var canOffsetX = _$8.get(options, 'canOffsetX') !== undefined ? _$8.get(options, 'canOffsetX') : this.canOffsetX;
      var canOffsetY = _$8.get(options, 'canOffsetY') !== undefined ? _$8.get(options, 'canOffsetY') : this.canOffsetY;
      var terOffsetX = _$8.get(options, 'terOffsetX') !== undefined ? _$8.get(options, 'terOffsetX') : this.terOffsetX;
      var terOffsetY = _$8.get(options, 'terOffsetY') !== undefined ? _$8.get(options, 'terOffsetY') : this.terOffsetY;
      var originX = _$8.get(options, 'originX') !== undefined ? _$8.get(options, 'originX') : this.originX || 0;
      var originY = _$8.get(options, 'originY') !== undefined ? _$8.get(options, 'originY') : this.originY || 0;

      if (pos === 'x') {
        var transformOriginX = originX / 100 * this.terWidth;
        return (coordinate - (transformOriginX * (1 - scale) + canOffsetX) - terOffsetX) / scale;
      }

      if (pos === 'y') {
        var transformOriginY = originY / 100 * this.terHeight;
        return (coordinate - (transformOriginY * (1 - scale) + canOffsetY) - terOffsetY) / scale;
      }
    }
  }]);

  return CoordinateService;
}();

var $$6 = require('jquery');

var _$9 = require('lodash');

var GridService = /*#__PURE__*/function () {
  function GridService(opts) {
    _classCallCheck(this, GridService);

    this.root = opts.root;
    this.canvas = opts.canvas;
    this.domWrapper = _$9.get(opts, 'canvas.wrapper');
    this.canvasHeight = 0;
    this.canvasWidth = 0;
    this.dom = null;
    this.isActive = false;
    this.theme = _$9.get(opts, 'theme', {}) || {
      shapeType: 'circle',
      // 展示的类型，支持line & circle
      gap: 5,
      // 网格间隙
      adsorbGap: '5px',
      // 吸附间距
      backgroud: '#fff',
      // 网格背景颜色
      lineColor: '#000',
      // 网格线条颜色
      lineWidth: '1px',
      // 网格粗细
      circleRadiu: 2,
      // 圆点半径
      circleColor: '#000' // 断电颜色

    };
  }

  _createClass(GridService, [{
    key: "create",
    value: function create() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.theme = _$9.merge(this.theme, options.theme || {});
      this.canvasHeight = $$6(this.root).height();
      this.canvasWidth = $$6(this.root).width();
      this.dom = $$6('<canvas class="butterfly-gird-canvas"></canvas>')[0];
      $$6(this.dom).attr('width', this.canvasWidth);
      $$6(this.dom).attr('height', this.canvasHeight);
      $$6(this.dom).appendTo(this.root);

      if (this.theme.shapeType === 'circle') {
        this.createCircle();
      } else if (this.theme.shapeType === 'line') {
        this.createLine();
      }

      this.isActive = true;
    }
  }, {
    key: "createCircle",
    value: function createCircle() {
      var _ctx = this.dom.getContext('2d');

      _ctx.fillStyle = this.theme.circleColor || '#000';

      var _p = Math.PI * 2;

      var _gap = parseInt(this.theme.gap);

      _gap = _gap < 5 ? 5 : _gap;

      for (var i = 0; i < this.canvasWidth; i += _gap) {
        for (var j = 0; j < this.canvasHeight; j += _gap) {
          _ctx.moveTo(i, j);

          _ctx.arc(i, j, this.theme.circleRadiu, 0, _p);
        }
      }

      _ctx.fill();
    }
  }, {
    key: "createLine",
    value: function createLine() {
      var _ctx = this.dom.getContext('2d');

      _ctx.strokeStyle = this.theme.lineColor || '#000';
      _ctx.lineWidth = this.theme.lineWidth || 1;

      var _gap = parseInt(this.theme.gap);

      _gap = _gap < 5 ? 5 : _gap;

      for (var j = 0; j < this.canvasHeight; j += _gap) {
        _ctx.beginPath();

        _ctx.moveTo(0, j);

        _ctx.lineTo(this.canvasWidth, j);

        _ctx.stroke();

        _ctx.closePath();
      }

      for (var i = 0; i < this.canvasWidth; i += _gap) {
        _ctx.beginPath();

        _ctx.moveTo(i, 0);

        _ctx.lineTo(i, this.canvasHeight);

        _ctx.stroke();

        _ctx.closePath();
      }

      _ctx.stroke();
    }
  }, {
    key: "justifyAllCoordinate",
    value: function justifyAllCoordinate() {
      var _this = this;

      var groups = this.canvas.groups;
      var nodes = this.canvas.nodes;

      var _justifyItem = function _justifyItem(item, type) {
        var _sx = item.left;
        var _sy = item.top;

        var _ex = item.left + item.getWidth();

        var _ey = item.top + item.getHeight();

        var _left = _sx % _this.theme.gap;

        var _right = _ex % _this.theme.gap;

        var _top = _sy % _this.theme.gap;

        var _bottom = _ey % _this.theme.gap;

        var _posLeft = _this.theme.gap - _left;

        var _posRight = _this.theme.gap - _right;

        var _posTop = _this.theme.gap - _top;

        var _posBottom = _this.theme.gap - _bottom;

        var _pos = {
          left: Infinity,
          right: Infinity,
          top: Infinity,
          bottom: Infinity
        };

        if (_left < _right && _left < _pos['left']) {
          _pos['left'] = _left;
        }

        if (_posLeft < _left && _posLeft < _pos['right']) {
          _pos['right'] = _posLeft;
        }

        if (_right < _left && _right < _pos['right']) {
          _pos['left'] = _right;
        }

        if (_posRight < _right && _posRight < _pos['left']) {
          _pos['right'] = _posRight;
        }

        if (_top < _bottom && _top < _pos['top']) {
          _pos['top'] = _top;
        }

        if (_posTop < _top && _posTop < _pos['bottom']) {
          _pos['bottom'] = _posTop;
        }

        if (_bottom < _top && _bottom < _pos['bottom']) {
          _pos['top'] = _bottom;
        }

        if (_posBottom < _bottom && _posBottom < _pos['top']) {
          _pos['bottom'] = _posBottom;
        }

        var result = [item.left, item.top];
        _pos['left'] = _pos['left'] <= _this.theme.adsorbGap ? _pos['left'] : Infinity;
        _pos['right'] = _pos['right'] <= _this.theme.adsorbGap ? _pos['right'] : Infinity;
        _pos['top'] = _pos['top'] <= _this.theme.adsorbGap ? _pos['top'] : Infinity;
        _pos['bottom'] = _pos['bottom'] <= _this.theme.adsorbGap ? _pos['bottom'] : Infinity;
        _pos['left'] < _pos['right'] && (result[0] -= _pos['left']);
        _pos['right'] < _pos['left'] && (result[0] += _pos['right']);
        _pos['top'] < _pos['bottom'] && (result[1] -= _pos['top']);
        _pos['bottom'] < _pos['top'] && (result[1] += _pos['bottom']);

        if (result[0] !== item.left || result[1] !== item.top) {
          if (type === 'node') {
            _this.canvas._moveNode(item, result[0], result[1]);
          } else if (type === 'group') {
            _this.canvas._moveGroup(item, result[0], result[1]);
          }
        }
      };

      groups.forEach(function (_group) {
        _justifyItem(_group, 'group');

        (_group.nodes || []).forEach(function (_node) {
          _justifyItem(_node, 'node');
        });
      });
      nodes.forEach(function (_node) {
        _justifyItem(_node, 'node');
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.dom.remove();
      this.isActive = false;
    }
  }]);

  return GridService;
}();

var $$7 = require('jquery');

var _$a = require('lodash');

var GuidelineService = /*#__PURE__*/function () {
  function GuidelineService(opts) {
    _classCallCheck(this, GuidelineService);

    this.root = opts.root;
    this.canvas = opts.canvas;
    this.dom = null;
    this.cxt = null;
    this.isActive = false;
    this.limitNum = opts.limitNum;
    this.theme = {
      lineColor: '#9fd1ff',
      lineWidth: 1
    };
  }

  _createClass(GuidelineService, [{
    key: "create",
    value: function create() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.theme = _$a.merge(this.theme, options.theme || {});
      this.canvasHeight = $$7(this.root).height();
      this.canvasWidth = $$7(this.root).width();
      this.dom = $$7('<div class="butterfly-gird-canvas-wrapper"></div>')[0];
      this.guideLineCanvas = $$7('<canvas class="butterfly-guideline-canvas"></canvas>')[0];
      $$7(this.guideLineCanvas).attr('width', this.canvasWidth);
      $$7(this.guideLineCanvas).attr('height', this.canvasHeight);
      $$7(this.guideLineCanvas).appendTo(this.dom);
      $$7(this.dom).appendTo(this.root);
      this.cxt = this.guideLineCanvas.getContext('2d');
      this.cxt.strokeStyle = this.theme.lineColor || '#000';
      this.cxt.lineWidth = this.theme.lineWidth || 1;
      this.isActive = true;
    }
  }, {
    key: "guidLine",
    value: function guidLine() {
      var moveTo = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0];
      var lineTo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0];

      var process = function process(coord) {
        return Math.floor(coord) + 0.5;
      };

      this.cxt.beginPath();
      this.cxt.moveTo(process(moveTo[0]), process(moveTo[1]));
      this.cxt.lineTo(process(lineTo[0]), process(lineTo[1]));
      this.cxt.stroke();
      this.cxt.closePath();
    }
  }, {
    key: "draw",
    value: function draw(item, type) {
      this.cxt.clearRect(0, 0, this.canvasWidth, this.canvasHeight);

      var _left = parseInt(item.left);

      var _right = parseInt(item.left + item.getWidth());

      var _top = parseInt(item.top);

      var _bottom = parseInt(item.top + item.getHeight());

      var _leftDis = Infinity;
      var _rightDis = Infinity;
      var _topDis = Infinity;
      var _bottomDis = Infinity;
      var _leftItem = null;
      var _rightItem = null;
      var _topItem = null;
      var _bottomItem = null;
      var groups = this.canvas.groups;
      var nodes = this.canvas.nodes;
      groups.forEach(function (_group) {
        if (type === 'group' && item.id === _group.id) {
          return;
        }

        var _groupLeft = parseInt(_group.left);

        var _groupRight = parseInt(_group.left + _group.getWidth());

        var _groupTop = parseInt(_group.top);

        var _groupBottom = parseInt(_group.top + _group.getHeight()); // 向左对齐的元素


        if (_left === _groupLeft) {
          if (Math.abs(_groupTop - _top) < _topDis) {
            _topDis = Math.abs(_groupTop - _top);
            _leftItem = _group;
          }
        } // 向右对齐的元素


        if (_right === _groupRight) {
          if (Math.abs(_groupBottom - _bottom) < _bottomDis) {
            _bottomDis = Math.abs(_groupBottom - _bottom);
            _rightItem = _group;
          }
        } // 向上对齐的元素


        if (_top === _groupTop) {
          if (Math.abs(_groupLeft - _left) < _leftDis) {
            _leftDis = Math.abs(_groupLeft - _left);
            _topItem = _group;
          }
        } // 向下对齐的元素


        if (_bottom === _groupBottom) {
          if (Math.abs(_groupRight - _right) < _rightDis) {
            _rightDis = Math.abs(_groupRight - _right);
            _bottomItem = _group;
          }
        }
      });
      nodes.forEach(function (_node) {
        if (type === 'node' && item.id === _node.id) {
          return;
        }

        var _nodeLeft = parseInt(_node.left);

        var _nodeRight = parseInt(_node.left + _node.getWidth());

        var _nodeTop = parseInt(_node.top);

        var _nodeBottom = parseInt(_node.top + _node.getHeight());

        if (_node._group) {
          _nodeLeft += _node._group.left;
          _nodeRight += _node._group.left;
          _nodeTop += _node._group.top;
          _nodeBottom += _node._group.top;
        } // 向左对齐的元素


        if (_left === _nodeLeft) {
          if (Math.abs(_nodeTop - _top) < _topDis) {
            _topDis = Math.abs(_nodeTop - _top);
            _leftItem = _node;
          }
        } // 向右对齐的元素


        if (_right === _nodeRight) {
          if (Math.abs(_nodeBottom - _bottom) < _bottomDis) {
            _bottomDis = Math.abs(_nodeBottom - _bottom);
            _rightItem = _node;
          }
        } // 向上对齐的元素


        if (_top === _nodeTop) {
          if (Math.abs(_nodeLeft - _left) < _leftDis) {
            _leftDis = Math.abs(_nodeLeft - _left);
            _topItem = _node;
          }
        } // 向下对齐的元素


        if (_bottom === _nodeBottom) {
          if (Math.abs(_nodeRight - _right) < _rightDis) {
            _rightDis = Math.abs(_nodeRight - _right);
            _bottomItem = _node;
          }
        }
      });

      if (_leftItem) {
        var startY = _top > _leftItem.top ? _leftItem.top : _top;
        var endY = _top > _leftItem.top ? _bottom : _leftItem.top + _leftItem.getHeight();
        this.guidLine([_left, startY], [_left, endY]);
      }

      if (_rightItem) {
        var _startY = _top > _rightItem.top ? _rightItem.top : _top;

        var _endY = _top > _rightItem.top ? _bottom : _rightItem.top + _rightItem.getHeight();

        this.guidLine([_right, _startY], [_right, _endY]);
      }

      if (_topItem) {
        var startX = _left > _topItem.left ? _topItem.left : _left;
        var endX = _left > _topItem.left ? _right : _topItem.left + _topItem.getWidth();
        this.guidLine([startX, _top], [endX, _top]);
      }

      if (_bottomItem) {
        var _startX = _left > _bottomItem.left ? _bottomItem.left : _left;

        var _endX = _left > _bottomItem.left ? _right : _bottomItem.left + _bottomItem.getWidth();

        this.guidLine([_startX, _bottom], [_endX, _bottom]);
      }
    }
  }, {
    key: "zoom",
    value: function zoom(scale) {
      $$7(this.dom).css({
        transform: "scale(".concat(scale, ")")
      });
      this.clearCanvas();
    }
  }, {
    key: "move",
    value: function move(x, y) {
      $$7(this.dom).css('left', x).css('top', y);
      this.clearCanvas();
    }
  }, {
    key: "clearCanvas",
    value: function clearCanvas() {
      this.cxt && this.cxt.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      $$7(this.dom).destroy();
      this.isActive = false;
    }
  }]);

  return GuidelineService;
}();

var _$b = require('lodash');

var $$8 = require('jquery'); // 每一个dot是一个圆形或者


var DOT_COLOR = 'rgba(76, 158, 164, 1)';
var GROUP_COLOR = 'rgba(61, 86, 92, 1)';
var DOT_ACTIVE_COLOR = 'rgba(255, 253, 76, 1)';
var GROUP_ACTIVE_COLOR = 'rgba(255, 253, 76, 1)';
var SAFE_DISTANCE = 20; // 修改一个element的css的属性

var modifyCSS = function modifyCSS(ele, cssStyle) {
  if (!ele || !ele.style) {
    return;
  }

  Object.keys(cssStyle).forEach(function (key) {
    ele.style[key] = cssStyle[key];
  });
}; // 获取Canvas缩放比，兼容高清屏


var getPixelRatio = function getPixelRatio(context) {
  var backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
  return (window.devicePixelRatio || 1) / backingStore;
}; // check constructor 的 options


var checkOpts = function checkOpts(options) {
  if (!options) {
    throw new Error('options cant be empty');
  }

  if (!options.root || _typeof(options.root) !== 'object' || !$$8(options.root)) {
    throw new Error('options.root must be a html element');
  }

  if (!options.move || typeof options.move !== 'function') {
    throw new Error('options.move must be a fuction');
  }

  if (!options.terminal2canvas || typeof options.terminal2canvas !== 'function') {
    throw new Error('options.move must be a fuction');
  }
};
/**
 * options:
 *  height {Number} 缩略图高度 default 200,
 *  width  {Number} 缩略图宽度 default 200,
 *  className {String} default: butterfly-minimap-container
 *  containerStyle {Object} 外层css
 *  viewportStyle {Object} 视口css
 *  backgroudStyle {Object} 底层css
 *  nodeColor {String} 节点颜色
 *  groupColor {String} 节点组颜色
 *  root {Element} 画布容器节点
 *  containerWidth {Number} 画布的宽度, 可自定义
 *  containerHeight {Number} 同上
 *  nodes {Pointer[]} 节点信息
 *    node.left, node.top 节点的坐标轴信息
 *  groups {Object[]} 节点组信息
 *    group.left, group.top, group.width, group.height 节点组的二维信息
 *  offset {Pointer} 偏移信息
 *  zoom {Number} 画布当前缩放比
 *  move {Function} 缩略图互动函数, 用于移动画布, 参考小蝴蝶的move
 *  terminal2canvas {Function} 互动函数, 屏幕坐标到画布坐标的转换
 *  safeDistance {Number} 画布视口在minimap距离边距的安全距离，默认20
 *  activeNodeColor {String} 选中的节点颜色
 *  activeGroupColor {String} 选中的节点组颜色
 *  events {String[]} 补充的监听事件
 */


var Minimap = /*#__PURE__*/function () {
  function Minimap(options) {
    var _this = this;

    _classCallCheck(this, Minimap);

    _defineProperty(this, "getItemsPoint", function () {
      var nodes = _$b.cloneDeep(_this.options.nodes);

      var groups = _$b.cloneDeep(_this.options.groups);

      var canvas2terminal = _this.options.canvas2terminal;

      var height = _this.$root.height();

      var width = _this.$root.width(); // 增加两个虚拟的点，防止只有一个node时宽度过大的问题


      nodes.push({
        left: 0,
        top: 0,
        height: 1,
        width: 1
      });
      nodes.push({
        left: width,
        top: height,
        height: 1,
        width: 1
      }); // 计算所有 nodes 的真实坐标

      var _iterator = _createForOfIteratorHelper(nodes),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var node = _step.value;

          if (node.group) {
            var group = _$b.find(groups, {
              id: node.group
            });

            if (!group) {
              continue;
            }

            node.rleft = group.left + node.left;
            node.rtop = group.top + node.top;
            continue;
          }

          node.rleft = node.left;
          node.rtop = node.top;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      groups.forEach(function (group) {
        var leftTop = [group.left, group.top];
        var rightBottom = [group.left + group.width, group.top + group.height];
        var screenLeftTop = canvas2terminal(leftTop);
        var screenRightBottom = canvas2terminal(rightBottom);
        group.screenLeftTop = screenLeftTop;
        group.screenRightBottom = screenRightBottom;
        group.left = screenLeftTop[0];
        group.top = screenLeftTop[1];
        group.width = screenRightBottom[0] - screenLeftTop[0];
        group.height = screenRightBottom[1] - screenLeftTop[1];
      });
      nodes.forEach(function (node) {
        var leftTop = [node.rleft, node.rtop];
        var rightBottom = [node.rleft + node.width, node.rtop + node.height];
        var screenLeftTop = canvas2terminal(leftTop);
        var screenRightBottom = canvas2terminal(rightBottom);
        node.left = screenLeftTop[0];
        node.top = screenLeftTop[1];
        node.width = screenRightBottom[0] - screenLeftTop[0];
        node.height = screenRightBottom[1] - screenLeftTop[1];
      });
      return {
        groups: groups,
        nodes: nodes
      };
    });

    _defineProperty(this, "getViewportBBox", function () {
      var $viewport = $$8(_this.viewportDOM);
      var parent = $viewport.offsetParent();
      var offset = $viewport.offset();
      var poffset = $$8(parent).offset();
      var left = offset.left - poffset.left;
      var top = offset.top - poffset.top;
      var width = $viewport.width();
      var height = $viewport.height();
      var right = left + width;
      var bottom = top + height;
      return {
        left: left,
        top: top,
        right: right,
        bottom: bottom,
        height: height,
        width: width
      };
    });

    _defineProperty(this, "debounceRender", _$b.debounce(function () {
      _this.renderViewPort();

      _this.renderBG();
    }, 100));

    checkOpts(options);
    this.root = options.root;
    this.$root = $$8(this.root);
    this.options = _objectSpread2({
      height: 200,
      width: 200,
      className: 'butterfly-minimap-container',
      containerStyle: {},
      viewportStyle: {},
      backgroudStyle: {},
      nodeColor: DOT_COLOR,
      groupColor: GROUP_COLOR,
      activeNodeColor: DOT_ACTIVE_COLOR,
      activeGroupColor: GROUP_ACTIVE_COLOR,
      containerWidth: $$8(this.root).width(),
      containerHeight: $$8(this.root).height(),
      nodes: [],
      groups: [],
      offset: [0, 0],
      zoom: 1,
      move: function move() {
        return null;
      },
      terminal2canvas: function terminal2canvas() {
        return null;
      },
      safeDistance: SAFE_DISTANCE
    }, options); // 画布到缩略图的缩放比

    this.ratio = 1; // 初始化容器

    this.initContainer(); // 渲染视口

    this.renderViewPort(); // 渲染背景

    this.renderBG();
  } // 获取所有元素的屏幕坐标


  _createClass(Minimap, [{
    key: "getBBox",
    // 获取画布的有内容的区域
    value: function getBBox() {
      var _this$getItemsPoint = this.getItemsPoint(),
          nodes = _this$getItemsPoint.nodes,
          groups = _this$getItemsPoint.groups;

      var check = function check(v) {
        return _$b.isNumber(v) ? v : 0;
      };

      var allNTop = nodes.map(function (node) {
        return node.top;
      });
      var allNLeft = nodes.map(function (node) {
        return node.left;
      });
      var allNBottom = nodes.map(function (node) {
        return node.top + node.height;
      });
      var allNRight = nodes.map(function (node) {
        return node.left + node.width;
      });
      var allGTop = groups.map(function (group) {
        return group.top;
      });
      var allGLeft = groups.map(function (group) {
        return group.left;
      });
      var allGBottom = groups.map(function (group) {
        return group.top + group.height;
      });
      var allGRight = groups.map(function (group) {
        return group.left + group.width;
      });
      var allTop = allNTop.concat(allGTop);
      var allLeft = allNLeft.concat(allGLeft);
      var allBottom = allNBottom.concat(allGBottom);
      var allRight = allNRight.concat(allGRight);
      var minX = check(_$b.min(allLeft));
      var minY = check(_$b.min(allTop));
      var maxX = check(_$b.max(allRight));
      var maxY = check(_$b.max(allBottom));
      return {
        minX: minX,
        minY: minY,
        width: maxX - minX,
        height: maxY - minY
      };
    } // 获取画布和缩略图的缩放比

  }, {
    key: "setRatio",
    value: function setRatio() {
      var height = this.options.height;
      var width = this.options.width;
      var graphSize = this.getBBox();

      if (graphSize.width === 0 || graphSize.height === 0) {
        return 0;
      }

      var ratio = Math.min(width / graphSize.width, height / graphSize.height);
      this.ratio = Number(ratio.toFixed(2));
    } // 更新小地图数据

  }, {
    key: "update",
    value: function update(_ref) {
      var _ref$nodes = _ref.nodes,
          nodes = _ref$nodes === void 0 ? [] : _ref$nodes,
          _ref$groups = _ref.groups,
          groups = _ref$groups === void 0 ? [] : _ref$groups,
          _ref$zoom = _ref.zoom,
          zoom = _ref$zoom === void 0 ? 1 : _ref$zoom,
          _ref$offset = _ref.offset,
          offset = _ref$offset === void 0 ? [0, 0] : _ref$offset;
      this.options.nodes = nodes;
      this.options.groups = groups;
      this.options.zoom = zoom;
      this.options.offset = offset;
      this.debounceRender();
    }
  }, {
    key: "initContainer",
    // 初始化画布
    value: function initContainer() {
      var _this$options = this.options,
          height = _this$options.height,
          width = _this$options.width,
          className = _this$options.className,
          viewportStyle = _this$options.viewportStyle,
          backgroudStyle = _this$options.backgroudStyle,
          containerStyle = _this$options.containerStyle;
      this.container = document.createElement('div');
      this.viewportDOM = document.createElement('div');
      this.backgroundDOM = document.createElement('div');
      this.container.setAttribute('class', className);
      var initStyle = {
        position: 'absolute',
        left: 0,
        top: 0,
        overflow: 'hidden',
        height: height + 'px',
        width: width + 'px'
      };
      modifyCSS(this.container, _objectSpread2(_objectSpread2({}, initStyle), {}, {
        right: '10px',
        bottom: '10px',
        left: 'none',
        top: 'none',
        height: height + 'px',
        width: width + 'px',
        border: '1px solid #aaa',
        'z-index': 100
      }, containerStyle));
      modifyCSS(this.viewportDOM, _objectSpread2(_objectSpread2({}, initStyle), {}, {
        left: 0,
        top: 0,
        // border: '1px solid pink',
        'background-color': 'rgba(79, 111, 126, 0.4)'
      }, viewportStyle));
      modifyCSS(this.backgroundDOM, _objectSpread2(_objectSpread2(_objectSpread2({}, initStyle), backgroudStyle), {}, {
        height: height + 'px',
        width: width + 'px'
      }));
      this.root.appendChild(this.container);
      this.container.appendChild(this.backgroundDOM);
      this.container.appendChild(this.viewportDOM);
      this.initBGCanvas();
      this.initViewportEvts();
    } // 创建BG canvas

  }, {
    key: "initBGCanvas",
    value: function initBGCanvas() {
      var _this$options2 = this.options,
          width = _this$options2.width,
          height = _this$options2.height;
      var canvasDom = document.createElement('canvas');
      this.backgroundDOM.appendChild(canvasDom);
      canvasDom.setAttribute('width', width);
      canvasDom.setAttribute('height', height);
      modifyCSS(canvasDom, {
        position: 'absolute',
        width: '100%',
        height: '100%',
        left: 0,
        top: 0
      });
      var cvsCtx = canvasDom.getContext('2d'); // 初始化2D画布

      this.cvsCtx = cvsCtx;
      this.cvsRatio = getPixelRatio(cvsCtx);
      cvsCtx.scale(this.cvsRatio, this.cvsRatio);
    } // 初始化视窗事件

  }, {
    key: "initViewportEvts",
    value: function initViewportEvts() {
      var _this2 = this;

      var dragging = false;
      var x = 0;
      var y = 0;
      var left = 0;
      var top = 0;
      this.viewportEvents = {
        mousedown: function mousedown(e) {
          e.preventDefault();
          e.stopPropagation();
          var viewportDOM = _this2.viewportDOM;

          if (e.target !== _this2.viewportDOM) {
            return;
          }

          var viewportBBox = _this2.getViewportBBox();

          left = parseInt(viewportBBox.left, 10);
          top = parseInt(viewportBBox.top, 10);
          dragging = true;
          x = e.clientX;
          y = e.clientY;
        },
        mousemove: function mousemove(e) {
          e.preventDefault();
          e.stopPropagation();

          if (!dragging || _$b.isNil(e.clientX) || _$b.isNil(e.clientY)) {
            return;
          }

          var dx = x - e.clientX;
          var dy = y - e.clientY;
          left -= dx;
          top -= dy;
          var _this2$options = _this2.options,
              mapWidth = _this2$options.width,
              mapHeight = _this2$options.height,
              safeDistance = _this2$options.safeDistance;

          var _this2$getViewportBBo = _this2.getViewportBBox(),
              vpWidth = _this2$getViewportBBo.width,
              vpHeight = _this2$getViewportBBo.height; // 限制视口不能够超出 minimap 的安全距离


          if (left >= mapWidth - safeDistance || top >= mapHeight - safeDistance || left + vpWidth <= safeDistance || top + vpHeight <= safeDistance) {
            left += dx;
            top += dy;
            return;
          }

          modifyCSS(_this2.viewportDOM, {
            left: left + 'px',
            top: top + 'px'
          });

          var _this2$getBBox = _this2.getBBox(),
              minX = _this2$getBBox.minX,
              minY = _this2$getBBox.minY;

          var offset = _this2.$root.offset();

          var boffset = _this2.options.offset;
          var ddx = (-left / _this2.ratio + offset.left - minX) * _this2.ratio;
          var ddy = (-top / _this2.ratio + offset.top - minY) * _this2.ratio;

          _this2.options.move([boffset[0] + ddx / _this2.ratio, boffset[1] + ddy / _this2.ratio]);

          x = e.clientX;
          y = e.clientY;
        },
        mouseleave: function mouseleave() {
          dragging = false;
        },
        mouseup: function mouseup() {
          dragging = false;
        }
      };
      Object.keys(this.viewportEvents).forEach(function (key) {
        _this2.container.addEventListener(key, _this2.viewportEvents[key]);
      });
    } // 渲染缩略图canvas

  }, {
    key: "renderBG",
    value: function renderBG() {
      var _this3 = this;

      var cvsCtx = this.cvsCtx;
      var _this$options3 = this.options,
          width = _this$options3.width,
          height = _this$options3.height,
          nodeColor = _this$options3.nodeColor,
          groupColor = _this$options3.groupColor,
          activeNodeColor = _this$options3.activeNodeColor,
          activeGroupColor = _this$options3.activeGroupColor;
      var cvsRatio = this.cvsRatio;
      cvsCtx.clearRect(0, 0, width, height); // 根据所有点的信息画出所有的点

      var _this$getItemsPoint2 = this.getItemsPoint(),
          nodes = _this$getItemsPoint2.nodes,
          groups = _this$getItemsPoint2.groups;

      var _this$getBBox = this.getBBox(),
          minX = _this$getBBox.minX,
          minY = _this$getBBox.minY;

      groups.forEach(function (group) {
        var left = (group.left - minX) * _this3.ratio;
        var top = (group.top - minY) * _this3.ratio;
        var width = group.width * _this3.ratio;
        var height = group.height * _this3.ratio;
        var minimapActive = group.minimapActive;

        if (minimapActive) {
          cvsCtx.fillStyle = activeGroupColor;
        } else {
          cvsCtx.fillStyle = groupColor;
        }

        cvsCtx.fillRect(left / cvsRatio, top / cvsRatio, width / cvsRatio, height / cvsRatio);
      });
      nodes.forEach(function (node) {
        var left = (node.left - minX) * _this3.ratio;
        var top = (node.top - minY) * _this3.ratio;
        var width = node.width * _this3.ratio;
        var height = node.height * _this3.ratio;

        if (node.minimapActive) {
          cvsCtx.fillStyle = activeNodeColor;
        } else {
          cvsCtx.fillStyle = nodeColor;
        } // cvsCtx.beginPath();


        cvsCtx.fillRect(left / cvsRatio, top / cvsRatio, width / cvsRatio, height / cvsRatio); // cvsCtx.arc(left / cvsRatio, top / cvsRatio, DOT_SIZE / cvsRatio, 0, 2*Math.PI);
        // cvsCtx.closePath();
        // cvsCtx.fill();
      });
    } // 绘制出拖动框

  }, {
    key: "renderViewPort",
    value: function renderViewPort() {
      this.setRatio();

      var _this$getBBox2 = this.getBBox(),
          minX = _this$getBBox2.minX,
          minY = _this$getBBox2.minY;

      var _this$$root$offset = this.$root.offset(),
          top = _this$$root$offset.top,
          left = _this$$root$offset.left;

      var rootWidth = this.$root.width();
      var rootHeight = this.$root.height();
      var offset = [left - minX, top - minY]; // 获取画布到minimap的缩放比

      var ratio = this.ratio;
      var vwidth = rootWidth * this.ratio;
      var vheight = rootHeight * this.ratio;
      var vleft = Math.round(Math.round(offset[0]) * ratio);
      var vtop = Math.round(Math.round(offset[1]) * ratio);
      modifyCSS(this.viewportDOM, {
        width: "".concat(vwidth, "px"),
        height: "".concat(vheight, "px"),
        left: "".concat(vleft, "px"),
        top: "".concat(vtop, "px")
      });
    } // 延时渲染

  }, {
    key: "destroy",
    value: function destroy() {
      // 销毁DOM
      this.root.removeChild(this.container);
    }
  }]);

  return Minimap;
}();

var $$9 = require('jquery');

var _$c = require('lodash');

var domtoimage = require('dom-to-image');

var BaseCanvas = /*#__PURE__*/function (_Canvas) {
  _inherits(BaseCanvas, _Canvas);

  var _super = _createSuper(BaseCanvas);

  function BaseCanvas(options) {
    var _this;

    _classCallCheck(this, BaseCanvas);

    _this = _super.call(this, options);
    _this.root = options.root;
    _this.layout = options.layout; // layout部分也需要重新review

    _this.zoomable = options.zoomable || false; // 可缩放

    _this.moveable = options.moveable || false; // 可平移

    _this.draggable = options.draggable || false; // 可拖动

    _this.linkable = options.linkable || false; // 可连线

    _this.disLinkable = options.disLinkable || false; // 可拆线

    _this.theme = {
      edge: {
        type: _$c.get(options, 'theme.edge.type') || 'Bezier',
        Class: _$c.get(options, 'theme.edge.Class') || BaseEdge,
        arrow: _$c.get(options, 'theme.edge.arrow'),
        arrowPosition: _$c.get(options, 'theme.edge.arrowPosition'),
        arrowOffset: _$c.get(options, 'theme.edge.arrowOffset'),
        label: _$c.get(options, 'theme.edge.label'),
        isRepeat: _$c.get(options, 'theme.edge.isRepeat') || false,
        isLinkMyself: _$c.get(options, 'theme.edge.isLinkMyself') || false,
        isExpandWidth: _$c.get(options, 'theme.edge.isExpandWidth') || false,
        defaultAnimate: _$c.get(options, 'theme.edge.defaultAnimate') || false
      },
      endpoint: {
        position: _$c.get(options, 'theme.endpoint.position'),
        linkableHighlight: _$c.get(options, 'theme.endpoint.linkableHighlight') || false,
        limitNum: _$c.get(options, 'theme.endpoint.limitNum'),
        expandArea: {
          left: _$c.get(options, 'theme.endpoint.expandArea.left') || 10,
          right: _$c.get(options, 'theme.endpoint.expandArea.right') || 10,
          top: _$c.get(options, 'theme.endpoint.expandArea.top') || 10,
          bottom: _$c.get(options, 'theme.endpoint.expandArea.bottom') || 10
        }
      },
      zoomGap: _$c.get(options, 'theme.zoomGap') || 0.001,
      // 鼠标到达边缘画布自动移动
      autoFixCanvas: {
        enable: _$c.get(options, 'theme.autoFixCanvas.enable', false),
        autoMovePadding: _$c.get(options, 'theme.autoFixCanvas.autoMovePadding') || [20, 20, 20, 20] // 上，右，下，左

      },
      // 自动适配父级div大小
      autoResizeRootSize: _$c.get(options, 'theme.autoResizeRootSize', true)
    }; // 贯穿所有对象的配置

    _this.global = _$c.get(options, 'global', {
      isScopeStrict: _$c.get(options, 'global.isScopeStrict'),
      // 是否为scope的严格模式
      limitQueueLen: 5 // 默认操作队列只有5步

    }); // 放大缩小和平移的数值

    _this._zoomData = 1;
    _this._moveData = [0, 0];
    _this._zoomTimer = null;
    _this.groups = [];
    _this.nodes = [];
    _this.edges = []; // 框选模式，需要重新考虑(默认单选)

    _this.isSelectMode = false;
    _this.selecContents = [];
    _this.selecMode = 'include';
    _this.selectItem = {
      nodes: [],
      edges: [],
      groups: [],
      endpoints: []
    }; // 框选前需要纪录状态

    _this._remarkZoom = undefined;
    _this._remarkMove = undefined;
    _this.svg = null;
    _this.wrapper = null;
    _this.canvasWrapper = null; // 加一层wrapper方便处理缩放，平移

    _this._genWrapper(); // 加一层svg画线条


    _this._genSvgWrapper(); // 加一层canvas方便处理辅助


    _this._genCanvasWrapper(); // 动画初始化


    LinkAnimateUtil.init(_this.svg); // 统一处理画布拖动事件

    _this._dragType = null;
    _this._dragNode = null;
    _this._dragEndpoint = null;
    _this._dragEdges = [];
    _this._dragGroup = null; // 初始化一些参数

    _this._rootWidth = $$9(_this.root).width();
    _this._rootHeight = $$9(_this.root).height(); // 网格布局

    _this._gridService = new GridService({
      root: _this.root,
      canvas: _assertThisInitialized(_this)
    }); // 辅助线

    _this._guidelineService = new GuidelineService({
      root: _this.root,
      canvas: _assertThisInitialized(_this)
    }); // 坐标转换服务

    _this._coordinateService = new CoordinateService({
      canvas: _assertThisInitialized(_this),
      terOffsetX: $$9(_this.root).offset().left,
      terOffsetY: $$9(_this.root).offset().top,
      terWidth: $$9(_this.root).width(),
      terHeight: $$9(_this.root).height(),
      canOffsetX: _this._moveData[0],
      canOffsetY: _this._moveData[1],
      scale: _this._zoomData
    });

    _this._addEventListener();

    _this._unionData = {
      __system: {
        nodes: [],
        edges: [],
        groups: [],
        endpoints: []
      }
    };
    _this._NodeClass = BaseNode; // undo & redo队列

    _this.actionQueue = [];
    _this.actionQueueIndex = -1; // 画布边缘

    _this._autoMoveDir = [];
    _this._autoMoveTimer = null;
    return _this;
  }

  _createClass(BaseCanvas, [{
    key: "updateRootResize",
    value: function updateRootResize() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this._coordinateService._changeCanvasInfo({
        terOffsetX: opts.terOffsetX || $$9(this.root).offset().left,
        terOffsetY: opts.terOffsetY || $$9(this.root).offset().top,
        terWidth: opts.terWidth || $$9(this.root).width(),
        terHeight: opts.terHeight || $$9(this.root).height()
      });

      this.canvasWrapper._changeCanvasInfo({
        terScrollX: opts.terScrollX || 0,
        terScrollY: opts.terScrollY || 0
      });
    }
  }, {
    key: "draw",
    value: function draw(opts, callback) {
      var _this2 = this;

      var groups = opts.groups || [];
      var nodes = opts.nodes || [];
      var edges = opts.edges || []; // 自动布局需要重新review

      if (this.layout) {
        this._autoLayout({
          groups: groups,
          nodes: nodes,
          edges: edges
        });
      } // 首次加载，异步逐步加载


      var groupPromise = new Promise(function (resolve, reject) {
        setTimeout(function () {
          // 生成groups
          _this2.addGroups(groups);

          resolve();
        });
      });
      var nodePromise = new Promise(function (resolve, reject) {
        setTimeout(function () {
          // 生成nodes
          _this2.addNodes(nodes);

          resolve();
        }, 10);
      });
      var edgePromise = new Promise(function (resolve, reject) {
        setTimeout(function () {
          // 生成edges
          _this2.addEdges(edges);

          resolve();
        }, 20);
      });
      Promise.all([groupPromise, nodePromise, edgePromise]).then(function () {
        _this2.actionQueue = [];
        _this2.actionQueueIndex = -1;
        callback && callback({
          nodes: _this2.nodes,
          edges: _this2.edges,
          groups: _this2.groups
        });
      });
    }
  }, {
    key: "redraw",
    value: function redraw(opts, callback) {
      this.removeNodes(this.nodes);
      this.removeGroups(this.groups);
      this.clearActionQueue();
      this.draw(opts, callback);
    }
  }, {
    key: "getNode",
    value: function getNode(id) {
      return _$c.find(this.nodes, function (item) {
        return item.id === id;
      });
    }
  }, {
    key: "getEdge",
    value: function getEdge(id) {
      return _$c.find(this.edges, function (item) {
        return item.id === id;
      });
    }
  }, {
    key: "getGroup",
    value: function getGroup(id) {
      return _$c.find(this.groups, function (item) {
        return item.id === id;
      });
    }
  }, {
    key: "addGroup",
    value: function addGroup(group, nodes, options, isNotEventEmit) {
      var _this3 = this;

      var container = $$9(this.wrapper);
      var GroupClass = group.Class || BaseGroup;
      var _newNodes = [];

      var _groupObj = new GroupClass(_$c.assign(_$c.cloneDeep(group), {
        _global: this.global,
        _emit: this.emit.bind(this),
        _on: this.on.bind(this),
        draggable: group.draggable !== undefined ? group.draggable : this.draggable
      }));

      if (this._isExistGroup(_groupObj)) {
        // 后续用新的group代码旧的group
        console.warn("group:".concat(_groupObj.id, " has existed"));
        return;
      }

      _groupObj.init();

      container.prepend(_groupObj.dom);
      this.groups.push(_groupObj);

      _groupObj._createEndpoint();

      _groupObj.mounted && _groupObj.mounted();

      if (nodes && nodes.length > 0) {
        // 过滤掉scope不匹配的节点 和 已存在其他组的node
        nodes = nodes.filter(function (_node) {
          return ScopeCompare(_node.scope, _groupObj.scope, _$c.get(_this3, 'global.isScopeStrict')) && (_node.group === _groupObj.id || _node.group == undefined);
        });

        var _isAbsolutePos = _$c.get(options, 'posType', 'absolute') === 'absolute'; // 重新计算group的位置


        var _groupLeft = Infinity;
        var _groupTop = Infinity;
        nodes.forEach(function (_node) {
          if (_isAbsolutePos) {
            if (_node.left < _groupLeft) {
              _groupLeft = _node.left;
            }

            if (_node.top < _groupTop) {
              _groupTop = _node.top;
            }
          }
        });

        _groupObj._moveTo(_groupLeft - _$c.get(options, 'padding', 5), _groupTop - _$c.get(options, 'padding', 5)); // 添加节点


        _newNodes = nodes.map(function (_node) {
          var newNode = null; // 已存在节点

          var _existNode = _$c.find(_this3.nodes, function (__node) {
            return __node.id === _node.id;
          });

          if (_existNode) {
            _this3.removeNode(_existNode.id, true, true);

            _existNode._init({
              dom: _existNode.dom,
              top: _existNode.top - _groupObj.top,
              left: _existNode.left - _groupObj.left,
              group: _groupObj.id
            });

            newNode = _this3.addNode(_existNode, true);
          } else {
            var _nodeObj = null;

            if (_node instanceof BaseNode || _node.__type === 'node') {
              _nodeObj = _node;
            } else {
              var _NodeClass = _node.Class || _this3._NodeClass;

              _nodeObj = new _NodeClass(_$c.assign(_$c.cloneDeep(_node), {
                _global: _this3.global,
                _on: _this3.on.bind(_this3),
                _emit: _this3.emit.bind(_this3),
                _endpointLimitNum: _this3.theme.endpoint.limitNum,
                draggable: _node.draggable !== undefined ? _node.draggable : _this3.draggable
              }));
            }

            if (_isAbsolutePos) {
              _nodeObj.top = _nodeObj.top - _groupObj.top;
              _nodeObj.left = _nodeObj.left - _groupObj.left;
            }

            _nodeObj.group = _groupObj.id;
            newNode = _this3.addNode(_nodeObj);
          }

          return newNode;
        }); // 重新计算group的大小

        var _groupWidth = -Infinity;

        var _groupHeight = -Infinity;

        _newNodes.forEach(function (_node) {
          var _w = $$9(_node.dom).width();

          var _h = $$9(_node.dom).height();

          if (_groupWidth < _node.left + _w) {
            _groupWidth = _node.left + _w;
          }

          if (_groupHeight < _node.top + _h) {
            _groupHeight = _node.top + _h;
          }
        });

        _groupObj.setSize(_groupWidth + _$c.get(options, 'padding', 5) * 2, _groupHeight + _$c.get(options, 'padding', 5) * 2);
      }

      if (!isNotEventEmit) {
        this.pushActionQueue({
          type: 'system:addGroups',
          data: [{
            group: _groupObj,
            nodes: _newNodes
          }]
        });
        this.emit('events', {
          type: 'group:add',
          group: _groupObj
        });
      }

      return _groupObj;
    }
  }, {
    key: "addNodes",
    value: function addNodes(nodes, isNotEventEmit) {
      var _this4 = this;

      var _canvasFragment = document.createDocumentFragment();

      var container = $$9(this.wrapper);
      var result = nodes.filter(function (node) {
        if (node.group) {
          var _existGroup = _this4.getGroup(node.group);

          if (!_existGroup) {
            console.warn("\bnodeId\u4E3A".concat(node.id, "\u7684\u8282\u70B9\u627E\u4E0D\u5230groupId\u4E3A").concat(node.group, "\u7684\u8282\u70B9\u7EC4\uFF0C\u56E0\u6B64\u65E0\u6CD5\u6E32\u67D3"));
            return false;
          }
        }

        return true;
      }).map(function (node) {
        var _nodeObj = null;

        if (node instanceof BaseNode || node.__type === 'node') {
          _nodeObj = node;
        } else {
          var _NodeClass = node.Class || _this4._NodeClass;

          _nodeObj = new _NodeClass(_$c.assign(_$c.cloneDeep(node), {
            _global: _this4.global,
            _on: _this4.on.bind(_this4),
            _emit: _this4.emit.bind(_this4),
            _endpointLimitNum: _this4.theme.endpoint.limitNum,
            draggable: node.draggable !== undefined ? node.draggable : _this4.draggable
          }));
        }

        if (_this4._isExistNode(_nodeObj)) {
          // 后续用新的node代码旧的node
          console.warn("node:".concat(_nodeObj.id, " has existed"));
          return;
        } // 节点初始化，假如已经存在过的节点就不需要重绘了


        var initObj = {};

        if (_nodeObj.dom) {
          initObj['dom'] = _nodeObj.dom;
        }

        _nodeObj._init(initObj); // 一定要比group的addNode执行的之前，不然会重复把node加到this.nodes里面


        _this4.nodes.push(_nodeObj); // 假如节点存在group，即放进对应的节点组里


        var existGroup = _nodeObj.group ? _this4.getGroup(_nodeObj.group) : null;

        if (existGroup) {
          if (ScopeCompare(_nodeObj.scope, existGroup.scope, _$c.get(_this4, 'global.isScopeStrict'))) {
            existGroup._appendNodes([_nodeObj]);
          } else {
            console.warn("nodeId\u4E3A".concat(_nodeObj.id, "\u7684\u8282\u70B9\u548CgroupId").concat(existGroup.id, "\u7684\u8282\u70B9\u7EC4scope\u503C\u4E0D\u7B26\uFF0C\u65E0\u6CD5\u52A0\u5165"));
          }
        } else {
          _canvasFragment.appendChild(_nodeObj.dom);
        }

        return _nodeObj;
      }).filter(function (item) {
        return !!item;
      }); // 批量插入dom，性能优化

      container.append(_canvasFragment);
      result.forEach(function (item) {
        // 渲染endpoint
        item._createEndpoint(isNotEventEmit); // 节点挂载


        !isNotEventEmit && item.mounted && item.mounted();
      });

      if (result && result.length > 0 && !isNotEventEmit) {
        this.pushActionQueue({
          type: 'system:addNodes',
          data: result
        });
        this.emit('system.nodes.add', {
          nodes: result
        });
        this.emit('events', {
          type: 'nodes:add',
          nodes: result
        });
      }

      return result;
    }
  }, {
    key: "addNode",
    value: function addNode(node, isNotEventEmit) {
      return this.addNodes([node], isNotEventEmit)[0];
    }
  }, {
    key: "addEdges",
    value: function addEdges(links, isNotEventEmit) {
      var _this5 = this;

      $$9(this.svg).css('visibility', 'hidden');

      var _edgeFragment = document.createDocumentFragment();

      var _labelFragment = document.createDocumentFragment();

      var result = links.map(function (link) {
        // link已经存在
        if (link instanceof BaseEdge) {
          link._init();

          _edgeFragment.appendChild(link.dom);

          if (link.labelDom) {
            _labelFragment.appendChild(link.labelDom);
          }

          if (link.arrowDom) {
            _edgeFragment.appendChild(link.arrowDom);
          }

          _this5.edges.push(link);

          link.mounted && link.mounted();
          return link;
        } // link不存在的话


        var EdgeClass = link.Class || _this5.theme.edge.Class;

        if (link.type === 'endpoint') {
          var sourceNode = null;
          var targetNode = null;
          var _sourceType = link._sourceType;
          var _targetType = link._targetType;

          if (link.sourceNode instanceof BaseNode || link.sourceNode.__type === 'node') {
            _sourceType = 'node';
            sourceNode = link.sourceNode;
          } else if (link.sourceNode instanceof BaseGroup || link.sourceNode.__type === 'group') {
            _sourceType = 'group';
            sourceNode = link.sourceNode;
          } else {
            if (link._sourceType) {
              sourceNode = _sourceType === 'node' ? _this5.getNode(link.sourceNode) : _this5.getGroup(link.sourceNode);
            } else {
              var _node = _this5.getNode(link.sourceNode);

              if (_node) {
                _sourceType = 'node';
                sourceNode = _node;
              } else {
                _sourceType = 'group';
                sourceNode = _this5.getGroup(link.sourceNode);
              }
            }
          }

          if (link.targetNode instanceof BaseNode || link.targetNode.__type === 'node') {
            _targetType = 'node';
            targetNode = link.targetNode;
          } else if (link.targetNode instanceof BaseGroup || link.targetNode.__type === 'group') {
            _targetType = 'group';
            targetNode = link.targetNode;
          } else {
            if (link._targetType) {
              targetNode = _targetType === 'node' ? _this5.getNode(link.targetNode) : _this5.getGroup(link.targetNode);
            } else {
              var _node2 = _this5.getNode(link.targetNode);

              if (_node2) {
                _targetType = 'node';
                targetNode = _node2;
              } else {
                _targetType = 'group';
                targetNode = _this5.getGroup(link.targetNode);
              }
            }
          }

          if (!sourceNode || !targetNode) {
            console.warn("butterflies error: can not connect edge. link sourceNodeId:".concat(link.sourceNode, ";link targetNodeId:").concat(link.targetNode));
            return;
          }

          var sourceEndpoint = null;
          var targetEndpoint = null;

          if (link.sourceEndpoint && (link.sourceEndpoint instanceof BaseEndpoint || link.sourceEndpoint.__type === 'endpoint')) {
            sourceEndpoint = link.sourceEndpoint;
          } else {
            sourceEndpoint = sourceNode.getEndpoint(link.source, 'source');
          }

          if (link.targetEndpoint && (link.targetEndpoint instanceof BaseEndpoint || link.targetEndpoint.__type === 'endpoint')) {
            targetEndpoint = link.targetEndpoint;
          } else {
            targetEndpoint = targetNode.getEndpoint(link.target, 'target');
          }

          if (!sourceEndpoint || !targetEndpoint) {
            console.warn("butterflies error: can not connect edge. link sourceId:".concat(link.source, ";link targetId:").concat(link.target));
            return;
          } // 线条去重


          if (!_this5.theme.edge.isRepeat) {
            var _isRepeat = _$c.some(_this5.edges, function (_edge) {
              var _result = false;

              if (sourceNode) {
                _result = sourceNode.id === _edge.sourceNode.id && sourceEndpoint.id === _edge.sourceEndpoint.id && _sourceType === _edge.sourceEndpoint.nodeType;
              }

              if (targetNode) {
                _result = _result && targetNode.id === _edge.targetNode.id && targetEndpoint === _edge.targetEndpoint.id && _targetType === _edge.targetEndpoint.nodeType;
              }

              return _result;
            });

            if (_isRepeat) {
              console.warn("id\u4E3A".concat(sourceEndpoint.id, "-").concat(targetEndpoint.id, "\u7684\u7EBF\u6761\u8FDE\u63A5\u91CD\u590D\uFF0C\u8BF7\u68C0\u67E5"));
              return;
            }
          }

          var edge = new EdgeClass({
            type: 'endpoint',
            id: link.id,
            label: link.label,
            shapeType: link.shapeType || _this5.theme.edge.type,
            orientationLimit: _this5.theme.endpoint.position,
            isExpandWidth: _this5.theme.edge.isExpandWidth,
            defaultAnimate: _this5.theme.edge.defaultAnimate,
            sourceNode: sourceNode,
            targetNode: targetNode,
            sourceEndpoint: sourceEndpoint,
            targetEndpoint: targetEndpoint,
            arrow: link.arrow === undefined ? _$c.get(_this5, 'theme.edge.arrow') : link.arrow,
            arrowPosition: link.arrowPosition === undefined ? _$c.get(_this5, 'theme.edge.arrowPosition') : link.arrowPosition,
            arrowOffset: link.arrowOffset === undefined ? _$c.get(_this5, 'theme.edge.arrowOffset') : link.arrowOffset,
            options: link,
            _sourceType: _sourceType,
            _targetType: _targetType,
            _global: _this5.global,
            _on: _this5.on.bind(_this5),
            _emit: _this5.emit.bind(_this5)
          });

          edge._init();

          _edgeFragment.appendChild(edge.dom);

          if (edge.labelDom) {
            _labelFragment.appendChild(edge.labelDom);
          }

          if (edge.arrowDom) {
            _edgeFragment.appendChild(edge.arrowDom);
          }

          _this5.edges.push(edge);

          edge.mounted && edge.mounted(); // 假如sourceEndpoint和targetEndpoint没属性，则自动添加上

          if (sourceEndpoint.type === undefined) {
            sourceEndpoint._tmpType = 'source';
          }

          if (targetEndpoint.type === undefined) {
            targetEndpoint._tmpType = 'target';
          }

          return edge;
        } else {
          var _sourceNode = _this5.getNode(link.source);

          var _targetNode = _this5.getNode(link.target);

          if (!_sourceNode || !_targetNode) {
            console.warn("butterflies error: can not connect edge. link sourceId:".concat(link.source, ";link targetId:").concat(link.target));
            return;
          }

          var _edge2 = new EdgeClass({
            type: 'node',
            id: link.id,
            label: link.label,
            sourceNode: _sourceNode,
            targetNode: _targetNode,
            shapeType: link.shapeType || _this5.theme.edge.type,
            orientationLimit: _this5.theme.endpoint.position,
            arrow: link.arrow === undefined ? _$c.get(_this5, 'theme.edge.arrow') : link.arrow,
            arrowPosition: link.arrowPosition === undefined ? _$c.get(_this5, 'theme.edge.arrowPosition') : link.arrowPosition,
            arrowOffset: link.arrowOffset === undefined ? _$c.get(_this5, 'theme.edge.arrowOffset') : link.arrowOffset,
            isExpandWidth: _this5.theme.edge.isExpandWidth,
            defaultAnimate: _this5.theme.edge.defaultAnimate,
            _global: _this5.global,
            _on: _this5.on.bind(_this5),
            _emit: _this5.emit.bind(_this5)
          });

          _edge2._init();

          _edgeFragment.appendChild(_edge2.dom);

          if (_edge2.labelDom) {
            _labelFragment.appendChild(_edge2.labelDom);
          }

          if (_edge2.arrowDom) {
            _edgeFragment.appendChild(_edge2.arrowDom);
          }

          _this5.edges.push(_edge2);

          _edge2.mounted && _edge2.mounted();
          return _edge2;
        }
      }).filter(function (item) {
        return item;
      });
      $$9(this.svg).append(_edgeFragment);
      $$9(this.wrapper).append(_labelFragment);
      result.forEach(function (link) {
        var _soucePoint = {};
        var _targetPoint = {};

        if (link.type === 'endpoint') {
          _soucePoint = {
            pos: [link.sourceEndpoint._posLeft + link.sourceEndpoint._width / 2, link.sourceEndpoint._posTop + link.sourceEndpoint._height / 2],
            orientation: link.sourceEndpoint.orientation ? link.sourceEndpoint.orientation : undefined
          };
          _targetPoint = {
            pos: [link.targetEndpoint._posLeft + link.targetEndpoint._width / 2, link.targetEndpoint._posTop + link.targetEndpoint._height / 2],
            orientation: link.targetEndpoint.orientation ? link.targetEndpoint.orientation : undefined
          };
        } else if (link.type === 'node') {
          _soucePoint = {
            pos: [link.sourceNode.left + link.sourceNode.getWidth() / 2, link.sourceNode.top + link.sourceNode.getHeight() / 2]
          };
          _targetPoint = {
            pos: [link.targetNode.left + link.targetNode.getWidth() / 2, link.targetNode.top + link.targetNode.getHeight() / 2]
          };
        }

        link.redraw(_soucePoint, _targetPoint);
      });

      if (!isNotEventEmit) {
        this.pushActionQueue({
          type: 'system:addEdges',
          data: result
        });
        this.emit('system.link.connect', {
          links: result
        });
        this.emit('events', {
          type: 'link:connect',
          links: result
        });
      }

      $$9(this.svg).css('visibility', 'visible');
      return result;
    }
  }, {
    key: "addEdge",
    value: function addEdge(link, isNotEventEmit) {
      return this.addEdges([link], isNotEventEmit)[0];
    }
  }, {
    key: "addGroups",
    value: function addGroups(datas) {
      var _this6 = this;

      return datas.map(function (item) {
        return _this6.addGroup(item);
      }).filter(function (item) {
        return item;
      });
    }
  }, {
    key: "removeNode",
    value: function removeNode(nodeId, isNotDelEdge, isNotEventEmit) {
      return this.removeNodes([nodeId], isNotDelEdge, isNotEventEmit);
    }
  }, {
    key: "removeNodes",
    value: function removeNodes(nodes, isNotDelEdge, isNotEventEmit) {
      var _this7 = this;

      var nodeIds = [];
      nodeIds = nodes.map(function (item) {
        if (item instanceof BaseNode) {
          return item.id;
        } else {
          return item;
        }
      });
      var rmNodes = [];
      var rmEdges = [];
      nodeIds.forEach(function (nodeId) {
        var index = _$c.findIndex(_this7.nodes, function (_node) {
          return _node.id === nodeId;
        });

        if (index === -1) {
          console.warn("\u627E\u4E0D\u5230id\u4E3A\uFF1A".concat(nodeId, "\u7684\u8282\u70B9"));
          return;
        } // 删除邻近的线条


        var neighborEdges = _this7.getNeighborEdges(nodeId);

        if (!isNotDelEdge) {
          _this7.removeEdges(neighborEdges, true, true);
        } // 删除节点


        var node = _this7.nodes[index];
        node.destroy(isNotEventEmit);

        var _rmNodes = _this7.nodes.splice(index, 1); // 假如在group里面


        if (node.group) {
          var group = _this7.getGroup(node.group);

          if (group) {
            group.nodes = group.nodes.filter(function (item) {
              return item.id !== node.id;
            });
          }
        }

        if (_rmNodes.length > 0) {
          rmNodes = rmNodes.concat(_rmNodes);
          rmEdges = rmEdges.concat(neighborEdges);
        }
      });

      if (rmNodes.length > 0) {
        if (!isNotEventEmit) {
          this.pushActionQueue({
            type: 'system:removeNodes',
            data: {
              nodes: rmNodes,
              edges: rmEdges
            }
          });
          this.emit('system.nodes.delete', {
            nodes: rmNodes,
            edges: rmEdges
          });
          this.emit('events', {
            type: 'nodes:delete',
            nodes: rmNodes,
            edges: rmEdges
          });
        }
      }

      return {
        nodes: rmNodes,
        edges: rmEdges
      };
    }
  }, {
    key: "removeEdges",
    value: function removeEdges(edges, isNotEventEmit, isNotPushActionQueue) {
      var _this8 = this;

      var result = [];
      edges.forEach(function (_edge) {
        var edgeIndex = -1;

        if (_edge instanceof BaseEdge || _edge.__type === 'edge') {
          edgeIndex = _$c.findIndex(_this8.edges, function (item) {
            if (item.type === 'node') {
              return _edge.sourceNode.id === item.sourceNode.id && _edge.targetNode.id === item.targetNode.id;
            } else {
              return _$c.get(_edge, 'sourceNode.id') === _$c.get(item, 'sourceNode.id') && _$c.get(_edge, 'sourceEndpoint.id') === _$c.get(item, 'sourceEndpoint.id') && _$c.get(_edge, 'sourceEndpoint.nodeType') === _$c.get(item, 'sourceEndpoint.nodeType') && _$c.get(_edge, 'targetNode.id') === _$c.get(item, 'targetNode.id') && _$c.get(_edge, 'targetEndpoint.id') === _$c.get(item, 'targetEndpoint.id') && _$c.get(_edge, 'targetEndpoint.nodeType') === _$c.get(item, 'targetEndpoint.nodeType');
            }
          });
        } else if (_$c.isString(_edge)) {
          edgeIndex = _$c.findIndex(_this8.edges, function (item) {
            return _edge === item.id;
          });
        } else {
          console.warn("\u5220\u9664\u7EBF\u6761\u9519\u8BEF\uFF0C\u4F20\u5165\u53C2\u6570\u6709\u8BEF\uFF0C\u8BF7\u68C0\u67E5");
          return;
        }

        if (edgeIndex !== -1) {
          result = result.concat(_this8.edges.splice(edgeIndex, 1));
        } else {
          console.warn("\u5220\u9664\u7EBF\u6761\u9519\u8BEF\uFF0C\u4E0D\u5B58\u5728\u503C\u4E3A".concat(_edge.id, "\u7684\u7EBF"));
        }
      });

      if (!isNotPushActionQueue) {
        this.pushActionQueue({
          type: 'system:removeEdges',
          data: result
        });
      }

      if (!isNotEventEmit) {
        this.emit('system.links.delete', {
          links: result
        });
        this.emit('events', {
          type: 'links:delete',
          links: result
        });
      }

      result.forEach(function (item) {
        item.destroy(isNotEventEmit);
      }); // 把endpoint重新赋值

      result.forEach(function (_rmEdge) {
        if (_$c.get(_rmEdge, 'sourceEndpoint._tmpType') === 'source') {
          var isExistEdge = _$c.some(_this8.edges, function (edge) {
            return _rmEdge.sourceNode.id === edge.sourceNode.id && _rmEdge.sourceEndpoint.id === edge.sourceEndpoint.id;
          });

          !isExistEdge && (_rmEdge.sourceEndpoint._tmpType = undefined);
        }

        if (_$c.get(_rmEdge, 'targetEndpoint._tmpType') === 'target') {
          var _isExistEdge = _$c.some(_this8.edges, function (edge) {
            return _rmEdge.targetNode.id === edge.targetNode.id && _rmEdge.targetEndpoint.id === edge.targetEndpoint.id;
          });

          !_isExistEdge && (_rmEdge.targetEndpoint._tmpType = undefined);
        }
      });
      return result;
    }
  }, {
    key: "removeEdge",
    value: function removeEdge(edge, isNotEventEmit, isNotPushActionQueue) {
      return this.removeEdges([edge], isNotEventEmit, isNotPushActionQueue)[0];
    }
  }, {
    key: "removeGroup",
    value: function removeGroup(data, isNotEventEmit) {
      var _this9 = this;

      var groupId = undefined;

      if (data instanceof BaseGroup) {
        groupId = data.id;
      } else {
        groupId = data;
      }

      var group = this.getGroup(groupId);

      if (!group) {
        console.warn("\u672A\u627E\u5230id\u4E3A".concat(groupId, "\u7684\u8282\u70B9\u7EC4"));
      }

      group._isDeleting = true;
      var insideNodes = group.nodes.map(function (_node) {
        var rmItem = _this9.removeNode(_node.id, true, true);

        var rmNode = rmItem.nodes[0];
        var neighborEdges = rmItem.edges;

        rmNode._init({
          top: _node.top + group.top,
          left: _node.left + group.left,
          dom: _node.dom,
          _isDeleteGroup: true
        });

        _this9.addNode(rmNode, true);

        neighborEdges.forEach(function (item) {
          item.redraw();
        });
        return rmNode;
      }); // 删除邻近的线条

      var neighborEdges = this.getNeighborEdges(group.id, 'group');
      this.removeEdges(neighborEdges, isNotEventEmit); // 删除group

      var index = _$c.findIndex(this.groups, function (_group) {
        return _group.id === groupId;
      });

      this.groups.splice(index, 1)[0];
      group.destroy(isNotEventEmit);

      if (isNotEventEmit) {
        this.pushActionQueue({
          type: 'system:removeGroup',
          data: {
            group: group,
            nodes: insideNodes
          }
        });
      }

      return group;
    }
  }, {
    key: "removeGroups",
    value: function removeGroups(groups, isNotEventEmit) {
      var _this10 = this;

      var groupIds = [];
      groupIds = groups.map(function (item) {
        if (item instanceof BaseGroup) {
          return item.id;
        } else {
          return item;
        }
      });
      var rmGroups = groupIds.map(function (item) {
        return _this10.removeGroup(item, isNotEventEmit);
      });
      return {
        groups: rmGroups
      };
    }
  }, {
    key: "getNeighborEdges",
    value: function getNeighborEdges(id, type) {
      var node = undefined;
      var group = undefined;

      if (type === 'node') {
        node = _$c.find(this.nodes, function (item) {
          return id === item.id;
        });
      } else if (type === 'group') {
        group = _$c.find(this.groups, function (item) {
          return id === item.id;
        });
      } else {
        node = _$c.find(this.nodes, function (item) {
          return id === item.id;
        });
        node && !type && (type = 'node');
        group = _$c.find(this.groups, function (item) {
          return id === item.id;
        });
        group && !type && (type = 'group');
      }

      return this.edges.filter(function (item) {
        if (type === 'node') {
          return _$c.get(item, 'sourceNode.id') === node.id || _$c.get(item, 'targetNode.id') === node.id;
        } else {
          return _$c.get(item, 'sourceNode.id') === group.id || _$c.get(item, 'targetNode.id') === group.id;
        }
      });
    }
  }, {
    key: "getNeighborNodes",
    value: function getNeighborNodes(nodeId) {
      var _this11 = this;

      var result = [];

      var node = _$c.find(this.nodes, function (item) {
        return nodeId === item.id;
      });

      if (!node) {
        console.warn("\u627E\u4E0D\u5230id\u4E3A".concat(nodeId, "\u7684\u8282\u70B9"));
      }

      this.edges.forEach(function (item) {
        if (item.sourceNode && item.sourceNode.id === nodeId) {
          result.push(item.targetNode.id);
        } else if (item.targetNode && item.targetNode.id === nodeId) {
          result.push(item.sourceNode.id);
        }
      });
      return result.map(function (id) {
        return _this11.getNode(id);
      });
    }
    /**
     * 查找 N 层节点
     * 
     * @param {Object} options 
     * @param {Node} options.node
     * @param {Endpoint} options.endpoint
     * @param {String} options.type
     * @param {Number} options.level
     * @param {Function} options.iteratee
     * @returns {Object} filteredGraph
     */

  }, {
    key: "getNeighborNodesAndEdgesByLevel",
    value: function getNeighborNodesAndEdgesByLevel(_ref) {
      var node = _ref.node,
          endpoint = _ref.endpoint,
          _ref$type = _ref.type,
          type = _ref$type === void 0 ? 'out' : _ref$type,
          _ref$level = _ref.level,
          level = _ref$level === void 0 ? Infinity : _ref$level,
          _ref$iteratee = _ref.iteratee,
          iteratee = _ref$iteratee === void 0 ? function () {
        return true;
      } : _ref$iteratee;
      // 先求source-target level 层
      if (!node || !this.nodes.length) return {
        nodes: [],
        edges: []
      };
      if (level == 0 || !this.edges.length) return {
        nodes: [node],
        edges: []
      };
      var quene = [];
      var neighbors = [];
      var visited = new Set(); // 1. 生成邻接表
      // adjTable = {[nodeId]: {[endpointId]: [[targetNode, targetEndpoint]]}}

      var adjTable = this.getAdjcentTable(type);

      if (endpoint) {
        quene = _$c.get(adjTable, [node.id, endpoint.id], []).map(function (d) {
          return [].concat(_toConsumableArray(d), [1]);
        });
      } else {
        quene = (Object.values(_$c.get(adjTable, node.id, {})) || []).flatMap(function (d) {
          return d.map(function (n) {
            return n.concat(1);
          });
        });
      }

      visited.add(node.id);
      if (!quene.length) return {
        nodes: [node],
        edges: []
      }; // 2. BFS,得到 nodes 集合

      var _loop = function _loop() {
        var _quene$shift = quene.shift(),
            _quene$shift2 = _slicedToArray(_quene$shift, 3),
            $node = _quene$shift2[0],
            $endpoint = _quene$shift2[1],
            $level = _quene$shift2[2];

        if (visited.has($node.id) || $level > level || !iteratee($node, $endpoint, $level)) return "continue"; // TODO: 锚点向后传递？节点向后传递？

        neighbors = (Object.values(_$c.get(adjTable, $node.id, {})) || []).forEach(function (neighborsWithEndpoint) {
          neighborsWithEndpoint.forEach(function (neighbor) {
            var _neighbor = _slicedToArray(neighbor, 2),
                $nNode = _neighbor[0],
                $nEndpoint = _neighbor[1];

            if (visited.has($nNode.id)) return;
            quene.push([].concat(_toConsumableArray(neighbor), [$level + 1]));
          });
        });
        visited.add($node.id);
      };

      while (quene.length) {
        var _ret = _loop();

        if (_ret === "continue") continue;
      }

      var nodes = new Set();
      var edges = new Set(); // 4. 获取 edges，1. 只考虑点集 2. 考虑边
      // 目前只考虑点集内的全部边

      this.edges.forEach(function (edge) {
        var sourceNode = edge.sourceNode,
            sourceEndpoint = edge.sourceEndpoint,
            targetNode = edge.targetNode,
            targetEndpoint = edge.targetEndpoint;

        if (visited.has(sourceNode.id) && visited.has(targetNode.id)) {
          nodes.add(sourceNode);
          nodes.add(targetNode);
          edges.add(edge);
        }
      });
      return {
        nodes: _toConsumableArray(nodes),
        edges: _toConsumableArray(edges)
      };
    }
  }, {
    key: "getAdjcentTable",
    value: function getAdjcentTable(type) {
      // 包含正逆的邻接表
      // {[nodeId]: {[endpointId]: [[targetNode, targetEndpoint]]}}
      var adjTable = {};
      this.edges.forEach(function (edge) {
        var sourceNode = edge.sourceNode,
            sourceEndpoint = edge.sourceEndpoint,
            targetNode = edge.targetNode,
            targetEndpoint = edge.targetEndpoint;
        var sourceNodeId = sourceNode.id;
        var sourceEndpointId = sourceEndpoint.id;
        var targetNodeId = targetNode.id;
        var targetEndpointId = targetEndpoint.id; // in and all

        if (type !== 'out') {
          if (!adjTable[targetNodeId]) adjTable[targetNodeId] = {};
          if (!adjTable[targetNodeId][targetEndpointId]) adjTable[targetNodeId][targetEndpointId] = [];
          adjTable[targetNodeId][targetEndpointId].push([sourceNode, sourceEndpoint]);
        } // out and all


        if (type !== 'in') {
          if (!adjTable[sourceNodeId]) adjTable[sourceNodeId] = {};
          if (!adjTable[sourceNodeId][sourceEndpointId]) adjTable[sourceNodeId][sourceEndpointId] = [];
          adjTable[sourceNodeId][sourceEndpointId].push([targetNode, targetEndpoint]);
        }
      });
      this.nodes.forEach(function (node) {
        if (!adjTable[node.id]) adjTable[node.id] = {};
      });
      return adjTable;
    }
  }, {
    key: "setZoomable",
    value: function setZoomable(flat) {
      var _this12 = this;

      var zoomDirection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._zoomDirection;

      if (zoomDirection !== undefined) {
        this._zoomDirection = zoomDirection;
      }

      if (!this._zoomCb) {
        this._zoomCb = function (event) {
          event.preventDefault();
          var deltaY = event.deltaY;

          if (_this12._zoomDirection) {
            _this12._zoomData -= deltaY * _this12.theme.zoomGap;
          } else {
            _this12._zoomData += deltaY * _this12.theme.zoomGap;
          }

          if (_this12._zoomData < 0.25) {
            _this12._zoomData = 0.25;
            return;
          }

          if (_this12._zoomData > 5) {
            _this12._zoomData = 5;
            return;
          }

          var platform = ['webkit', 'moz', 'ms', 'o'];
          var scale = "scale(".concat(_this12._zoomData, ")");

          for (var i = 0; i < platform.length; i++) {
            _this12.wrapper.style["".concat(platform[i], "Transform")] = scale;
          }

          _this12.wrapper.style.transform = scale;

          _this12._coordinateService._changeCanvasInfo({
            wrapper: _this12.wrapper,
            girdWrapper: _this12._guidelineService.dom,
            mouseX: event.clientX,
            mouseY: event.clientY,
            scale: _this12._zoomData
          });

          _this12._guidelineService.zoom(_this12._zoomData);

          _this12.emit('system.canvas.zoom', {
            zoom: _this12._zoomData
          });

          _this12.emit('events', {
            type: 'canvas.zoom',
            zoom: _this12._zoomData
          });
        };
      }

      if (flat) {
        // 双指Mac下缩放正常，Window鼠标滑轮方向相反
        this.root.addEventListener('wheel', this._zoomCb);
      } else {
        this.root.removeEventListener('wheel', this._zoomCb);
      }
    }
  }, {
    key: "setMoveable",
    value: function setMoveable(flat) {
      if (flat) {
        this.moveable = true;

        if (this._dragType === 'canvas:drag') {
          this.moveable = false;
        }
      } else {
        this.moveable = false;
      }
    }
  }, {
    key: "setLinkable",
    value: function setLinkable(flat) {
      this.linkable = !!flat;
    }
  }, {
    key: "setDisLinkable",
    value: function setDisLinkable(flat) {
      this.disLinkable = !!flat;
    }
  }, {
    key: "setDraggable",
    value: function setDraggable(flat) {
      this.nodes.forEach(function (node) {
        node.setDraggable(flat);
      });
      this.draggable = flat;
    }
  }, {
    key: "focusNodesWithAnimate",
    value: function focusNodesWithAnimate(param) {
      var _this13 = this;

      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['node'];
      var options = arguments.length > 2 ? arguments[2] : undefined;
      var callback = arguments.length > 3 ? arguments[3] : undefined;
      // 画布里的可视区域
      var canLeft = Infinity;
      var canRight = -Infinity;
      var canTop = Infinity;
      var canBottom = -Infinity;

      if (_$c.includes(type, 'node')) {
        var nodeIds = param.nodes;
        this.nodes.filter(function (_node) {
          return _$c.find(nodeIds, function (id) {
            return _node.id === id;
          }) !== undefined;
        }).forEach(function (_node) {
          var _nodeLeft = _node.left;

          var _nodeRight = _node.left + _node.getWidth();

          var _nodeTop = _node.top;

          var _nodeBottom = _node.top + _node.getHeight();

          if (_node.group) {
            var group = _this13.getGroup(_node.group);

            if (group) {
              _nodeLeft += group.left;
              _nodeRight += group.left;
              _nodeTop += group.top;
              _nodeBottom += group.top;
            }
          }

          if (_nodeLeft < canLeft) {
            canLeft = _nodeLeft;
          }

          if (_nodeRight > canRight) {
            canRight = _nodeRight;
          }

          if (_nodeTop < canTop) {
            canTop = _nodeTop;
          }

          if (_nodeBottom > canBottom) {
            canBottom = _nodeBottom;
          }
        });
      }

      if (_$c.includes(type, 'group')) {
        var groupIds = param.groups;
        this.groups.filter(function (_group) {
          return _$c.find(groupIds, function (id) {
            return id === _group.id;
          });
        }).forEach(function (_group) {
          var _groupLeft = _group.left;

          var _groupRight = _group.left + _group.getWidth();

          var _groupTop = _group.top;

          var _groupBottom = _group.top + _group.getHeight();

          if (_groupLeft < canLeft) {
            canLeft = _groupLeft;
          }

          if (_groupRight > canRight) {
            canRight = _groupRight;
          }

          if (_groupTop < canTop) {
            canTop = _groupTop;
          }

          if (_groupBottom > canBottom) {
            canBottom = _groupBottom;
          }
        });
      }

      var customOffset = _$c.get(options, 'offset') || [0, 0];
      var canDisX = canRight - canLeft;
      var terDisX = this._rootWidth - customOffset[0];
      var canDisY = canBottom - canTop;
      var terDisY = this._rootHeight - customOffset[1];
      var scaleX = terDisX / canDisX;
      var scaleY = terDisY / canDisY; // 这里要根据scale来判断

      var scale = scaleX < scaleY ? scaleX : scaleY;
      scale = 1 < scale ? 1 : scale;

      var terLeft = this._coordinateService._canvas2terminal('x', canLeft, {
        scale: scale,
        canOffsetX: 0,
        canOffsetY: 0,
        terOffsetX: 0,
        terOffsetY: 0,
        originX: 50,
        originY: 50
      });

      var terRight = this._coordinateService._canvas2terminal('x', canRight, {
        scale: scale,
        canOffsetX: 0,
        canOffsetY: 0,
        terOffsetX: 0,
        terOffsetY: 0,
        originX: 50,
        originY: 50
      });

      var terTop = this._coordinateService._canvas2terminal('y', canTop, {
        scale: scale,
        canOffsetX: 0,
        canOffsetY: 0,
        terOffsetX: 0,
        terOffsetY: 0,
        originX: 50,
        originY: 50
      });

      var terBottom = this._coordinateService._canvas2terminal('y', canBottom, {
        scale: scale,
        canOffsetX: 0,
        canOffsetY: 0,
        terOffsetX: 0,
        terOffsetY: 0,
        originX: 50,
        originY: 50
      });

      var offsetX = (terLeft + terRight - this._rootWidth) / 2;
      var offsetY = (terTop + terBottom - this._rootHeight) / 2;
      offsetX = -offsetX + customOffset[0];
      offsetY = -offsetY + customOffset[1];
      var time = 500;
      $$9(this.wrapper).animate({
        top: offsetY,
        left: offsetX
      }, time);
      this._moveData = [offsetX, offsetY];

      this._coordinateService._changeCanvasInfo({
        canOffsetX: offsetX,
        canOffsetY: offsetY,
        scale: scale,
        originX: 50,
        originY: 50
      });

      this.zoom(scale, callback);
    }
  }, {
    key: "focusCenterWithAnimate",
    value: function focusCenterWithAnimate(options, callback) {
      var nodeIds = this.nodes.map(function (item) {
        return item.id;
      });
      var groupIds = this.groups.map(function (item) {
        return item.id;
      });
      this.focusNodesWithAnimate({
        nodes: nodeIds,
        groups: groupIds
      }, ['node', 'group'], options, callback);
    }
  }, {
    key: "focusNodeWithAnimate",
    value: function focusNodeWithAnimate(param) {
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'node';
      var options = arguments.length > 2 ? arguments[2] : undefined;
      var callback = arguments.length > 3 ? arguments[3] : undefined;
      var node = null;

      if (_$c.isFunction(param)) {
        // 假如传入的是filter，则按照用户自定义的规则来寻找
        node = type === 'node' ? _$c.find(this.nodes, param) : _$c.find(this.groups, param);
      } else {
        // 假如传入的是id，则按照默认规则寻找
        node = type === 'node' ? _$c.find(this.nodes, function (item) {
          return item.id === param;
        }) : _$c.find(this.groups, function (item) {
          return item.id === param;
        });
      }

      var top = 0;
      var left = 0;

      if (!node) {
        return;
      }

      top = node.top || node.y;
      left = node.left || node.x;

      if (node.height) {
        top += node.height / 2;
      }

      if (node.width) {
        left += node.width / 2;
      }

      if (node.group) {
        var group = _$c.find(this.groups, function (_group) {
          return _group.id === node.group;
        });

        if (!group) return;
        top += group.top || group.y;
        left += group.left || group.x;

        if (group.height) {
          top += group.height / 2;
        }

        if (group.width) {
          left += group.width / 2;
        }
      }

      var customOffset = _$c.get(options, 'offset') || [0, 0];
      var containerW = this._rootWidth;
      var containerH = this._rootHeight;
      var targetY = containerH / 2 - top + customOffset[1];
      var targetX = containerW / 2 - left + customOffset[0];
      var time = 500; // animate不支持scale，使用setInterval自己实现

      $$9(this.wrapper).animate({
        top: targetY,
        left: targetX
      }, time);
      this._moveData = [targetX, targetY];

      this._coordinateService._changeCanvasInfo({
        canOffsetX: targetX,
        canOffsetY: targetY,
        originX: 50,
        originY: 50,
        scale: 1
      });

      this.zoom(1, callback);
      this._guidelineService.isActive && this._guidelineService.clearCanvas();
    }
  }, {
    key: "zoom",
    value: function zoom(param, callback) {
      var _this14 = this;

      if (param < 0.25) {
        param = 0.25;
      }

      if (param > 5) {
        param = 5;
      }

      var time = 50;
      var frame = 1;
      var gap = param - this._zoomData;
      var interval = gap / 20;
      clearInterval(this._zoomTimer);
      this._zoomTimer = null;

      if (gap !== 0) {
        this._zoomTimer = setInterval(function () {
          _this14._zoomData += interval;
          var _canvasInfo = {
            scale: _this14._zoomData
          };

          if (_this14._coordinateService.originX === undefined || _this14._coordinateService.originY === undefined) {
            _canvasInfo['originX'] = 50;
            _canvasInfo['originY'] = 50;
          }

          _this14._coordinateService._changeCanvasInfo(_canvasInfo);

          _this14._guidelineService.zoom(_this14._zoomData);

          $$9(_this14.wrapper).css({
            transform: "scale(".concat(_this14._zoomData, ")")
          });

          if (frame === 20) {
            clearInterval(_this14._zoomTimer);

            _this14.emit('system.canvas.zoom', {
              zoom: _this14._zoomData
            });

            _this14.emit('events', {
              type: 'canvas.zoom',
              zoom: _this14._zoomData
            });

            callback && callback();
          }

          frame++;
        }, time / 20);
      } else {
        callback && callback();
      }
    }
  }, {
    key: "setOrigin",
    value: function setOrigin(data) {
      var originX = (data[0] || '0').toString().replace('%', '');
      var originY = (data[1] || '0').toString().replace('%', '');

      this._coordinateService._changeCanvasInfo({
        originX: parseFloat(originX),
        originY: parseFloat(originY)
      });
    }
  }, {
    key: "move",
    value: function move(position) {
      $$9(this.wrapper).css('left', position[0]).css('top', position[1]);

      this._coordinateService._changeCanvasInfo({
        canOffsetX: position[0],
        canOffsetY: position[1]
      });

      this._guidelineService.isActive && this._guidelineService.move(position[0], position[1]);
      this._moveData = position;
      this.emit('system.canvas.move');
      this.emit('events', {
        type: 'system.canvas.move'
      });
    }
  }, {
    key: "getZoom",
    value: function getZoom() {
      return this._zoomData;
    }
  }, {
    key: "getOffset",
    value: function getOffset() {
      return this._moveData;
    }
  }, {
    key: "getOrigin",
    value: function getOrigin() {
      return [this._coordinateService.originX + '%', this._coordinateService.originY + '%'];
    }
  }, {
    key: "getDataMap",
    value: function getDataMap() {
      return {
        nodes: this.nodes,
        edges: this.edges,
        groups: this.groups
      };
    }
  }, {
    key: "setSelectMode",
    value: function setSelectMode() {
      var flat = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var contents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['node'];
      var selecMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'include';

      if (flat) {
        this.isSelectMode = true;

        this._rmSystemUnion();

        this.selecContents = contents;
        this.selecMode = selecMode;
        this.canvasWrapper.active();
        this._remarkMove = this.moveable;
        this._remarkZoom = this.zoomable;
        this.setZoomable(false);
        this.setMoveable(false);
      } else {
        this.isSelectMode = false;
        this.canvasWrapper.unActive();

        if (this._remarkMove) {
          this.setMoveable(true);
        }

        if (this._remarkZoom) {
          this.setZoomable(true);
        }
      }
    }
  }, {
    key: "setGirdMode",
    value: function setGirdMode() {
      var flat = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var options = arguments.length > 1 ? arguments[1] : undefined;

      if (flat) {
        this._gridService.create(options);
      } else {
        this._gridService.destroy();
      }
    }
  }, {
    key: "setGuideLine",
    value: function setGuideLine() {
      var flat = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var options = arguments.length > 1 ? arguments[1] : undefined;

      if (flat) {
        this._guidelineService.create(options);
      } else {
        this._guidelineService.destroy();
      }
    }
  }, {
    key: "setMinimap",
    value: function setMinimap() {
      var _this15 = this;

      var flat = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!options.events) {
        options.events = [];
      }

      var updateEvts = ['system.canvas.zoom', 'system.node.delete', 'system.node.move', 'system.nodes.add', 'system.group.delete', 'system.group.move', 'system.drag.move', 'system.canvas.move'].concat(_toConsumableArray(options.events));

      var getNodes = function getNodes() {
        return _this15.nodes.map(function (node) {
          return {
            id: node.id,
            left: node.left,
            top: node.top,
            width: node.getWidth(),
            height: node.getHeight(),
            group: node.group,
            minimapActive: _$c.get(node, 'options.minimapActive')
          };
        });
      };

      var getGroups = function getGroups() {
        return _this15.groups.map(function (group) {
          return {
            id: group.id,
            left: group.left,
            top: group.top,
            width: group.getWidth(),
            height: group.getHeight(),
            minimapActive: _$c.get(group, 'options.minimapActive')
          };
        });
      };

      if (flat && !this.minimap) {
        this.minimap = new Minimap(_objectSpread2({
          root: this.root,
          move: this.move.bind(this),
          terminal2canvas: this.terminal2canvas.bind(this),
          canvas2terminal: this.canvas2terminal.bind(this),
          nodes: getNodes(),
          groups: getGroups(),
          zoom: this.getZoom(),
          offset: this.getOffset()
        }, options));

        this.updateFn = function () {
          _this15.minimap.update({
            nodes: getNodes(),
            groups: getGroups(),
            zoom: _this15.getZoom(),
            offset: _this15.getOffset()
          });
        };

        var _iterator = _createForOfIteratorHelper(updateEvts),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var ev = _step.value;
            this.on(ev, this.updateFn);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return;
      }

      if (!this.minimap) {
        return;
      }

      this.minimap.destroy();

      var _iterator2 = _createForOfIteratorHelper(updateEvts),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _ev = _step2.value;
          this.off(_ev, this.updateFn);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      delete this.minimap;
      delete this.updateFn;
    }
  }, {
    key: "getUnion",
    value: function getUnion(name) {
      if (!name) {
        console.error('传入正确的name');
        return;
      }

      return this._unionData[name];
    }
  }, {
    key: "getAllUnion",
    value: function getAllUnion() {
      return this._unionData;
    }
  }, {
    key: "add2Union",
    value: function add2Union(name, obj) {
      var _this16 = this;

      if (!name || !obj) {
        return;
      }

      if (!this._unionData[name]) {
        this._unionData[name] = {
          nodes: [],
          groups: [],
          edges: [],
          endpoints: []
        };
      }

      var _data = this._unionData[name];

      if (obj.nodes) {
        obj.nodes.forEach(function (item) {
          var isId = _$c.isString(item);

          var node = isId ? _this16.getNode(item) : item;

          _data.nodes.push(node);
        });
        _data.nodes = _$c.uniqBy(_data.nodes, 'id');
      }

      if (obj.groups) {
        obj.groups.forEach(function (item) {
          var isId = _$c.isString(item);

          var group = isId ? _this16.getGroup(item) : item;

          _data.groups.push(group);
        });
        _data.groups = _$c.uniqBy(_data.groups, 'id');
      }

      if (obj.edges) {
        obj.edges.forEach(function (item) {
          var isId = _$c.isString(item);

          var edge = isId ? _this16.getEdge(item) : item;

          _data.edges.push(edge);
        });
        _data.edges = _$c.uniqBy(_data.edges, 'id');
      }

      if (obj.endpoints) {
        _data.endpoints = _data.endpoints.concat(obj.endpoints);
      }
    }
  }, {
    key: "removeUnion",
    value: function removeUnion(name) {
      this._unionData[name] = {
        nodes: [],
        edges: [],
        groups: [],
        endpoints: []
      };
    }
  }, {
    key: "removeAllUnion",
    value: function removeAllUnion() {
      this._unionData = {
        __system: {
          nodes: [],
          edges: [],
          groups: [],
          endpoints: []
        }
      };
    }
  }, {
    key: "_rmSystemUnion",
    value: function _rmSystemUnion() {
      this._unionData['__system'].nodes = [];
      this._unionData['__system'].edges = [];
      this._unionData['__system'].groups = [];
      this._unionData['__system'].endpoints = [];
    }
  }, {
    key: "_findUnion",
    value: function _findUnion(type, item) {
      var result = [];

      for (var key in this._unionData) {
        var isExist = _$c.find(_$c.get(this._unionData, [key, type], []), function (_item) {
          return _$c.toString(_item.id) === _$c.toString(item.id);
        });

        if (isExist) {
          result.push(key);
        }
      }

      return result;
    }
  }, {
    key: "canvas2terminal",
    value: function canvas2terminal(coordinates, options) {
      return this._coordinateService.canvas2terminal(coordinates, options);
    }
  }, {
    key: "terminal2canvas",
    value: function terminal2canvas(coordinates, options) {
      return this._coordinateService.terminal2canvas(coordinates, options);
    }
  }, {
    key: "save2img",
    value: function save2img(options) {
      var method = 'toPng';

      switch (options.type) {
        case 'jpeg':
        case '.jpeg':
          method = 'toJpeg';
          break;

        case 'png':
        case '.png':
          method = 'toPng';
          break;

        case 'svg':
        case '.svg':
          method = 'toSvg';
          break;
      }

      return domtoimage[method](this.root, options).then(function (dataUrl) {
        return dataUrl;
      })["catch"](function (error) {
        console.error('oops, something went wrong!', error);
      });
    }
  }, {
    key: "justifyCoordinate",
    value: function justifyCoordinate() {
      this._gridService.justifyAllCoordinate();
    }
  }, {
    key: "_genSvgWrapper",
    value: function _genSvgWrapper() {
      function _detectMob() {
        var toMatch = [/Android/i, /webOS/i, /iPhone/i, /iPad/i, /iPod/i, /BlackBerry/i, /Windows Phone/i];
        return toMatch.some(function (toMatchItem) {
          return window.navigator.userAgent.match(toMatchItem);
        });
      }

      var _isMobi = _detectMob();

      var _SVGWidth = '100%';
      var _SVGHeight = '100%';

      var _detectZoom = function _detectZoom() {
        var ratio = 0;
        var screen = window.screen;
        var ua = navigator.userAgent.toLowerCase();

        if (window.devicePixelRatio !== undefined) {
          ratio = window.devicePixelRatio;
        } else if (~ua.indexOf('msie')) {
          if (screen.deviceXDPI && screen.logicalXDPI) {
            ratio = screen.deviceXDPI / screen.logicalXDPI;
          }
        } else if (window.outerWidth !== undefined && window.innerWidth !== undefined) {
          ratio = window.outerWidth / window.innerWidth;
        }

        if (ratio) {
          ratio = Math.round(ratio * 100);
        }

        return ratio;
      }; // hack 适配浏览器的缩放比例


      if (!_isMobi) {
        var _sclae = 1 / (_detectZoom() / 200);

        _SVGWidth = 1 * _sclae + 'px';
        _SVGHeight = 1 * _sclae + 'px';
      } // 生成svg的wrapper


      var svg = $$9(document.createElementNS('http://www.w3.org/2000/svg', 'svg')).attr('class', 'butterfly-svg').attr('width', _SVGWidth).attr('height', _SVGHeight).attr('version', '1.1').attr('xmlns', 'http://www.w3.org/2000/svg').appendTo(this.wrapper);

      if (!_isMobi) {
        // hack 监听浏览器的缩放比例并适配
        window.onresize = function () {
          var _sclae = 1 / (_detectZoom() / 200);

          svg.attr('width', 1 * _sclae + 'px').attr('height', 1 * _sclae + 'px');
        }; // hack 因为width和height为1的时候会有偏移


        var wrapperOffset = $$9(this.wrapper)[0].getBoundingClientRect();
        var svgOffset = svg[0].getBoundingClientRect();
        svg.css('top', wrapperOffset.top - svgOffset.top + 'px').css('left', wrapperOffset.left - svgOffset.left + 'px');
      }

      return this.svg = svg;
    }
  }, {
    key: "_genWrapper",
    value: function _genWrapper() {
      // 生成wrapper
      var wrapper = $$9('<div class="butterfly-wrapper"></div>').appendTo(this.root);
      return this.wrapper = wrapper[0];
    }
  }, {
    key: "_genCanvasWrapper",
    value: function _genCanvasWrapper() {
      // 生成canvas wrapper
      this.canvasWrapper = new SelectCanvas();
      this.canvasWrapper.init({
        root: this.root,
        _on: this.on.bind(this),
        _emit: this.emit.bind(this)
      });
    }
  }, {
    key: "_addEventListener",
    value: function _addEventListener() {
      var _this17 = this;

      if (this.zoomable) {
        this.setZoomable(true);
      }

      if (this.moveable) {
        this.setMoveable(true);
      }

      var _isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);

      var _getChromeVersion = function _getChromeVersion() {
        var raw = window.navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
        return raw ? parseInt(raw[2], 10) : false;
      };

      var _isHightVerChrome = _isChrome && _getChromeVersion() >= 64; // todo：chrome64版本ResizeObserver对象不存在，但官方文档说64支持，所以加强判断下


      if (_isHightVerChrome && window.ResizeObserver && this.theme.autoResizeRootSize) {
        // 监听某个dom的resize事件
        var _resizeObserver = new ResizeObserver(function (entries) {
          _this17._rootWidth = $$9(_this17.root).width();
          _this17._rootHeight = $$9(_this17.root).height();

          _this17._coordinateService._changeCanvasInfo({
            terOffsetX: $$9(_this17.root).offset().left,
            terOffsetY: $$9(_this17.root).offset().top,
            terWidth: $$9(_this17.root).width(),
            terHeight: $$9(_this17.root).height()
          });

          _this17.canvasWrapper.resize({
            root: _this17.root
          });
        });

        _resizeObserver.observe(this.root);
      } else {
        //  降级处理，监控窗口的resize事件
        window.addEventListener('resize', function () {
          _this17._rootWidth = $$9(_this17.root).width();
          _this17._rootHeight = $$9(_this17.root).height();

          _this17._coordinateService._changeCanvasInfo({
            terOffsetX: $$9(_this17.root).offset().left,
            terOffsetY: $$9(_this17.root).offset().top,
            terWidth: $$9(_this17.root).width(),
            terHeight: $$9(_this17.root).height()
          });

          _this17.canvasWrapper.resize({
            root: _this17.root
          });
        });
      } // 绑定一大堆事件，group:addMember，groupDragStop，group:removeMember，beforeDetach，connection，


      this.on('InnerEvents', function (data) {
        if (data.type === 'node:addEndpoint') {
          _this17._addEndpoint(data.data, 'node', data.isInited);
        } else if (data.type === 'node:removeEndpoint') {
          var _point = data.data;

          var rmEdges = _this17.edges.filter(function (item) {
            return item.sourceNode.id === _point.nodeId && item.sourceEndpoint.id === _point.id || item.targetNode.id === _point.nodeId && item.targetEndpoint.id === _point.id;
          });

          _this17.removeEdges(rmEdges);
        } else if (data.type === 'group:addEndpoint') {
          _this17._addEndpoint(data.data, 'group', data.isInited);
        } else if (data.type === 'node:dragBegin') {
          _this17._dragType = 'node:drag';
          _this17._dragNode = data.data;
        } else if (data.type === 'node:mouseDown') {
          _this17._dragType = 'node:mouseDown';
        } else if (data.type === 'group:dragBegin') {
          _this17._dragType = 'group:drag';
          _this17._dragNode = data.data;
        } else if (data.type === 'endpoint:drag') {
          _this17._dragType = 'endpoint:drag';
          _this17._dragEndpoint = data.data;
        } else if (data.type === 'node:move') {
          _this17._moveNode(data.node, data.x, data.y, data.isNotEventEmit);
        } else if (data.type === 'group:move') {
          _this17._moveGroup(data.group, data.x, data.y, data.isNotEventEmit);
        } else if (data.type === 'link:click') {
          _this17._dragType = 'link:click';
        } else if (data.type === 'multiple:select') {
          var result = _this17._selectMultiplyItem(data.range, data.toDirection); // 把框选的加到union的数组


          _$c.assign(_this17._unionData['__system'], _this17.selectItem);

          _this17.emit('system.multiple.select', {
            data: result
          });

          _this17.emit('events', {
            type: 'multiple:select',
            data: result
          });

          _this17.selectItem = {
            nodes: [],
            edges: [],
            endpoints: []
          };
        } else if (data.type === 'group:resize') {
          _this17._dragType = 'group:resize';
          _this17._dragGroup = data.group;
        } else if (data.type === 'node:delete') {
          _this17.removeNode(data.data.id);
        } else if (data.type === 'edge:delete') {
          _this17.removeEdge(data.data);
        } else if (data.type === 'group:delete') {
          _this17.removeGroup(data.data.id);
        } else if (data.type === 'group:addNodes') {
          _$c.get(data, 'nodes', []).forEach(function (item) {
            var _hasNode = _$c.find(_this17.nodes, function (_node) {
              return item.id === _node.id;
            });

            if (!_hasNode) {
              _this17.addNode(item);
            } else {
              var neighborEdges = [];

              var rmItem = _this17.removeNode(item.id, true, true);

              var rmNode = rmItem.nodes[0];
              var _group = data.group;
              neighborEdges = rmItem.edges;

              rmNode._init({
                top: item.top - _group.top,
                left: item.left - _group.left,
                dom: rmNode.dom,
                group: _group.id
              });

              _this17.addNode(rmNode, true);
            }
          });

          if (!data.isNotEventEmit) {
            _this17.emit('events', {
              type: 'system.group.addMembers',
              nodes: data.nodes,
              group: data.group
            });

            _this17.emit('system.group.addMembers', {
              nodes: data.nodes,
              group: data.group
            });
          }
        } else if (data.type === 'group:removeNodes') {
          var _group = data.group;

          _$c.get(data, 'nodes', []).forEach(function (item) {
            _this17.removeNode(item.id, true, true);

            item._init({
              group: undefined,
              left: item.left + _group.left,
              top: item.top + _group.top,
              dom: item.dom,
              _isDeleteGroup: true
            });

            _this17.addNode(item, true);
          });
        } else if (data.type === 'edge:updateLabel') {
          var labelDom = data.data.labelDom;
          $$9(_this17.wrapper).append(labelDom);
        }
      }); // 绑定拖动事件

      this._attachMouseDownEvent();
    }
  }, {
    key: "_isExistNode",
    value: function _isExistNode(node) {
      var hasNodes = this.nodes.filter(function (item) {
        return item.id === node.id;
      });
      return hasNodes.length > 0;
    }
  }, {
    key: "_isExistGroup",
    value: function _isExistGroup(group) {
      var hasGroups = this.groups.filter(function (item) {
        return item.id === group.id;
      });
      return hasGroups.length > 0;
    }
  }, {
    key: "_addEndpoint",
    value: function _addEndpoint(endpoint, type, isInited) {
      var initOtps = {
        nodeType: type,
        _coordinateService: this._coordinateService
      };

      endpoint._init(initOtps); // 非自定义dom，自定义dom不需要定位


      if (!endpoint._isInitedDom) {
        var endpointDom = endpoint.dom;

        if (_$c.get(endpoint, '_node.group')) {
          var group = this.getGroup(endpoint._node.group);
          $$9(group.dom).append(endpointDom);
        } else {
          $$9(this.wrapper).prepend(endpointDom);
        }

        endpoint.updatePos();
      }

      endpoint.mounted && endpoint.mounted();
    }
  }, {
    key: "_attachMouseDownEvent",
    value: function _attachMouseDownEvent() {
      var _this18 = this;

      var canvasOriginPos = {
        x: 0,
        y: 0
      };
      var nodeOriginPos = {
        x: 0,
        y: 0
      };
      var _isActiveEndpoint = false;
      var _activeItems = []; // 把其他可连接的point高亮

      var _activeLinkableEndpoint = function _activeLinkableEndpoint(target) {
        if (_isActiveEndpoint) {
          return;
        }

        var _allPoints = _this18._getAllEndpoints();

        _allPoints.forEach(function (_point) {
          if (target === _point || _point.type === 'source' || _point._tmpType === 'source') {
            return;
          }

          if (_point.canLink && _point.canLink(target)) {
            if (_point.linkable) {
              _point.linkable();

              _point._linkable = true;
            }

            return;
          }

          if (ScopeCompare(target.scope, _point.scope)) {
            if (_point.linkable) {
              _point.linkable();

              _point._linkable = true;
            }

            _activeItems.push(_point);

            return;
          }
        });

        _isActiveEndpoint = true;
      }; // 把其他可连接的point取消高亮


      var _unActiveLinkableEndpoint = function _unActiveLinkableEndpoint() {
        _isActiveEndpoint = false;

        _activeItems.forEach(function (item) {
          item.unLinkable && item.unLinkable();
          item.unHoverLinkable && item.unHoverLinkable();
          item._linkable = false;
        });

        _activeItems = [];
      };

      var _oldFocusPoint = null;
      var _isFocusing = false; // 检查鼠标是否在可连的锚点上

      var _focusLinkableEndpoint = function _focusLinkableEndpoint(cx, cy) {
        if (!_isFocusing) {
          // if (_focusPoint) {
          //   _focusPoint.unHoverLinkable && _focusPoint.unHoverLinkable();
          //   _focusPoint = null;
          // }
          _isFocusing = true;
          setTimeout(function () {
            var _points = _this18._getAllEndpoints();

            var x = _this18._coordinateService._terminal2canvas('x', cx);

            var y = _this18._coordinateService._terminal2canvas('y', cy);

            var _focusPoint = null;

            _points.forEach(function (_point) {
              var _maxX = _point._posLeft + _point._width + (_$c.get(_point, 'expandArea.right') || _this18.theme.endpoint.expandArea.right);

              var _maxY = _point._posTop + _point._height + (_$c.get(_point, 'expandArea.bottom') || _this18.theme.endpoint.expandArea.bottom);

              var _minX = _point._posLeft - (_$c.get(_point, 'expandArea.left') || _this18.theme.endpoint.expandArea.left);

              var _minY = _point._posTop - (_$c.get(_point, 'expandArea.top') || _this18.theme.endpoint.expandArea.top);

              if (x > _minX && x < _maxX && y > _minY && y < _maxY) {
                _focusPoint = _point;
              }
            });

            if (_focusPoint) {
              if (_focusPoint !== _oldFocusPoint) {
                _focusPoint.hoverLinkable && _focusPoint.hoverLinkable();
                _oldFocusPoint = _focusPoint;
              }
            } else {
              if (_oldFocusPoint) {
                _oldFocusPoint.unHoverLinkable && _oldFocusPoint.unHoverLinkable();
                _oldFocusPoint = null;
              }
            }

            _isFocusing = false;
          }, 100);
        }
      };

      var mouseDownEvent = function mouseDownEvent(event) {
        var LEFT_BUTTON = 0;

        if (event.button !== LEFT_BUTTON) {
          return;
        }

        if (!_this18._dragType && _this18.moveable) {
          _this18._dragType = 'canvas:drag';
        } // 假如点击在空白地方且在框选模式下


        if ((event.target === _this18.svg[0] || event.target === _this18.root) && _this18.isSelectMode) {
          _this18.canvasWrapper.active();

          _this18.canvasWrapper.dom.dispatchEvent(new MouseEvent('mousedown', {
            clientX: event.clientX,
            clientY: event.clientY
          }));

          return;
        }

        canvasOriginPos = {
          x: event.clientX,
          y: event.clientY
        };

        _this18.emit('system.drag.start', {
          dragType: _this18._dragType,
          dragNode: _this18._dragNode,
          dragEndpoint: _this18._dragEndpoint,
          dragEdges: _this18._dragEdges,
          dragGroup: _this18._dragGroup,
          position: {
            clientX: event.clientX,
            clientY: event.clientY,
            canvasX: _this18._coordinateService._terminal2canvas('x', event.clientX),
            canvasY: _this18._coordinateService._terminal2canvas('y', event.clientY)
          }
        });

        _this18.emit('events', {
          type: 'drag:start',
          dragType: _this18._dragType,
          dragNode: _this18._dragNode,
          dragEndpoint: _this18._dragEndpoint,
          dragEdges: _this18._dragEdges,
          dragGroup: _this18._dragGroup,
          position: {
            clientX: event.clientX,
            clientY: event.clientY,
            canvasX: _this18._coordinateService._terminal2canvas('x', event.clientX),
            canvasY: _this18._coordinateService._terminal2canvas('y', event.clientY)
          }
        });

        _this18._autoMoveDir = [];
      };

      var mouseMoveEvent = function mouseMoveEvent(event) {
        var LEFT_BUTTON = 0;

        if (event.button !== LEFT_BUTTON) {
          return;
        }

        if (_this18._dragType) {
          var canvasX = _this18._coordinateService._terminal2canvas('x', event.clientX);

          var canvasY = _this18._coordinateService._terminal2canvas('y', event.clientY);

          var offsetX = event.clientX - canvasOriginPos.x;
          var offsetY = event.clientY - canvasOriginPos.y;

          if (_this18._dragType === 'canvas:drag') {
            _this18.move([offsetX + _this18._moveData[0], offsetY + _this18._moveData[1]]);

            canvasOriginPos = {
              x: event.clientX,
              y: event.clientY
            };
          } else if (_this18._dragType === 'node:drag') {
            if (nodeOriginPos.x === 0 && nodeOriginPos.y === 0) {
              nodeOriginPos = {
                x: canvasX,
                y: canvasY
              };
              return;
            }

            if (_this18._dragNode) {
              var moveNodes = [_this18._dragNode];

              var unionKeys = _this18._findUnion('nodes', _this18._dragNode);

              if (unionKeys && unionKeys.length > 0) {
                unionKeys.forEach(function (key) {
                  moveNodes = moveNodes.concat(_this18._unionData[key].nodes);
                });
                moveNodes = _$c.uniqBy(moveNodes, 'id');
              } else {
                _this18._rmSystemUnion();
              }

              $$9(_this18.svg).css('visibility', 'hidden');
              $$9(_this18.wrapper).css('visibility', 'hidden');
              moveNodes.forEach(function (node) {
                _this18._moveNode(node, node.left + (canvasX - nodeOriginPos.x), node.top + (canvasY - nodeOriginPos.y));

                if (_this18._guidelineService.isActive) {
                  _this18._guidelineService.draw(node, 'node');
                }
              });
              $$9(_this18.svg).css('visibility', 'visible');
              $$9(_this18.wrapper).css('visibility', 'visible');
              nodeOriginPos = {
                x: canvasX,
                y: canvasY
              };

              _this18.emit('system.node.move', {
                nodes: moveNodes
              });

              _this18.emit('events', {
                type: 'node:move',
                nodes: moveNodes
              });

              _this18._autoMoveCanvas(event.clientX, event.clientY, {
                type: 'node:drag',
                nodes: moveNodes
              }, function (gap) {
                nodeOriginPos.x += gap[0];
                nodeOriginPos.y += gap[1];
              });
            }
          } else if (_this18._dragType === 'group:drag') {
            if (nodeOriginPos.x === 0 && nodeOriginPos.y === 0) {
              nodeOriginPos = {
                x: canvasX,
                y: canvasY
              };
              return;
            }

            if (_this18._dragNode) {
              $$9(_this18.svg).css('visibility', 'hidden');
              $$9(_this18.wrapper).css('visibility', 'hidden');
              var group = _this18._dragNode;

              _this18._moveGroup(group, group.left + (canvasX - nodeOriginPos.x), group.top + (canvasY - nodeOriginPos.y));

              if (_this18._guidelineService.isActive) {
                _this18._guidelineService.draw(group, 'group');
              }

              $$9(_this18.svg).css('visibility', 'visible');
              $$9(_this18.wrapper).css('visibility', 'visible');
              nodeOriginPos = {
                x: canvasX,
                y: canvasY
              };

              _this18.emit('system.group.move', {
                group: group
              });

              _this18.emit('events', {
                type: 'group:move',
                group: group
              });

              _this18._autoMoveCanvas(event.clientX, event.clientY, {
                type: 'group:drag',
                group: group
              }, function (gap) {
                nodeOriginPos.x += gap[0];
                nodeOriginPos.y += gap[1];
              });
            }
          } else if (_this18._dragType === 'endpoint:drag') {
            var endX = _this18._coordinateService._terminal2canvas('x', event.clientX);

            var endY = _this18._coordinateService._terminal2canvas('y', event.clientY); // 明确标记source或者是没有type且没有线连上


            var _isSourceEndpoint = _this18._dragEndpoint.type === 'source' || _this18._dragEndpoint.type === 'onlyConnect' || !_this18._dragEndpoint.type && (!_this18._dragEndpoint._tmpType || _this18._dragEndpoint._tmpType === 'source');

            var _isTargetEndpoint = (_this18._dragEndpoint.type === 'target' || !_this18._dragEndpoint.type && _this18._dragEndpoint._tmpType === 'target') && !_this18._dragEndpoint.type === 'onlyConnect';

            if (_isSourceEndpoint && _this18.linkable) {
              var _unionKeys = _this18._findUnion('endpoints', _this18._dragEndpoint);

              var edges = [];

              if (!_this18._dragEdges || _this18._dragEdges.length === 0) {
                var EdgeClass = _this18.theme.edge.Class;
                var endpoints = [];

                if (_unionKeys && _unionKeys.length > 0) {
                  _unionKeys.forEach(function (key) {
                    endpoints = endpoints.concat(_this18._unionData[key].endpoints);
                  });

                  endpoints = _$c.uniqBy(endpoints, function (_point) {
                    return _point.nodeId + '||' + _point.id;
                  });
                } else {
                  endpoints = [_this18._dragEndpoint];
                }

                endpoints.forEach(function (point) {
                  var pointObj = {
                    type: 'endpoint',
                    shapeType: _this18.theme.edge.type,
                    orientationLimit: _this18.theme.endpoint.position,
                    _sourceType: point.nodeType,
                    sourceNode: point.nodeType === 'node' ? _this18.getNode(point.nodeId) : _this18.getGroup(point.nodeId),
                    sourceEndpoint: point,
                    arrow: _this18.theme.edge.arrow,
                    arrowPosition: _this18.theme.edge.arrowPosition,
                    arrowOffset: _this18.theme.edge.arrowOffset,
                    label: _this18.theme.edge.label,
                    isExpandWidth: _this18.theme.edge.isExpandWidth
                  }; // 检查endpoint限制连接数目

                  var _linkNums = _this18.edges.filter(function (_edge) {
                    return _edge.sourceEndpoint.id === point.id;
                  }).length + 1;

                  if (_linkNums > point.limitNum) {
                    console.warn("id\u4E3A".concat(point.id, "\u7684\u951A\u70B9\u9650\u5236\u4E86").concat(point.limitNum, "\u6761\u8FDE\u7EBF"));
                    return;
                  }

                  var _newEdge = new EdgeClass(_$c.assign(pointObj, {
                    _global: _this18.global,
                    _on: _this18.on.bind(_this18),
                    _emit: _this18.emit.bind(_this18)
                  }));

                  _newEdge._init();

                  $$9(_this18.svg).append(_newEdge.dom);

                  if (_newEdge.labelDom) {
                    $$9(_this18.wrapper).append(_newEdge.labelDom);
                  }

                  if (_newEdge.arrowDom) {
                    $$9(_this18.svg).append(_newEdge.arrowDom);
                  }

                  edges.push(_newEdge);
                });
                _this18._dragEdges = edges;
              } else {
                edges = _this18._dragEdges;
              }

              $$9(_this18.svg).css('visibility', 'hidden');
              $$9(_this18.wrapper).css('visibility', 'hidden');
              var _targetPoint = {
                pos: [endX, endY]
              };
              edges.forEach(function (edge) {
                var beginX = edge.sourceEndpoint._posLeft + edge.sourceEndpoint._width / 2;
                var beginY = edge.sourceEndpoint._posTop + edge.sourceEndpoint._height / 2;
                var _soucePoint = {
                  pos: [beginX, beginY],
                  orientation: edge.sourceEndpoint.orientation
                };
                edge.redraw(_soucePoint, _targetPoint);
              });
              $$9(_this18.svg).css('visibility', 'visible');
              $$9(_this18.wrapper).css('visibility', 'visible');

              if (_this18.theme.endpoint.linkableHighlight) {
                _activeLinkableEndpoint(_this18._dragEndpoint);

                _focusLinkableEndpoint(event.clientX, event.clientY);
              }

              _this18._autoMoveCanvas(event.clientX, event.clientY, {
                type: 'endpoint:drag',
                edges: edges
              }, function (gap) {
                edges.forEach(function (edge) {
                  var beginX = edge.sourceEndpoint._posLeft + edge.sourceEndpoint._width / 2;
                  var beginY = edge.sourceEndpoint._posTop + edge.sourceEndpoint._height / 2;
                  var _soucePoint = {
                    pos: [beginX, beginY],
                    orientation: edge.sourceEndpoint.orientation
                  };
                  _targetPoint.pos[0] += gap[0];
                  _targetPoint.pos[1] += gap[1];
                  edge.redraw(_soucePoint, _targetPoint);
                });
              });

              _this18.emit('system.drag.move', {
                dragType: _this18._dragType,
                pos: [event.clientX, event.clientY],
                dragNode: _this18._dragNode,
                dragEndpoint: _this18._dragEndpoint,
                dragEdges: edges
              });

              _this18.emit('events', {
                type: 'drag:move',
                dragType: _this18._dragType,
                pos: [event.clientX, event.clientY],
                dragNode: _this18._dragNode,
                dragEndpoint: _this18._dragEndpoint,
                dragEdges: edges
              });
            } else if (_isTargetEndpoint && _this18.disLinkable) {
              // 从后面搜索线
              var targetEdge = null;

              for (var i = _this18.edges.length - 1; i >= 0; i--) {
                if (_this18._dragEndpoint.id === _$c.get(_this18.edges, [i, 'targetEndpoint', 'id']) && _this18._dragEndpoint.nodeId === _$c.get(_this18.edges, [i, 'targetNode', 'id'])) {
                  targetEdge = _this18.edges[i];
                  break;
                }
              }

              if (targetEdge && _this18._dragEdges.length === 0) {
                targetEdge._isDeletingEdge = true;
                _this18._dragEdges = [targetEdge];
              }

              if (_this18._dragEdges.length !== 0) {
                var edge = _this18._dragEdges[0];
                var beginX = edge.sourceEndpoint._posLeft + edge.sourceEndpoint._width / 2;
                var beginY = edge.sourceEndpoint._posTop + edge.sourceEndpoint._height / 2;
                var _soucePoint = {
                  pos: [beginX, beginY],
                  orientation: edge.sourceEndpoint.orientation
                };
                var _targetPoint2 = {
                  pos: [endX, endY]
                };
                edge.redraw(_soucePoint, _targetPoint2);
              }

              if (_this18.theme.endpoint.linkableHighlight) {
                _activeLinkableEndpoint(_this18._dragEndpoint);

                _focusLinkableEndpoint(event.clientX, event.clientY);
              }
            }
          } else if (_this18._dragType === 'group:resize') {
            var _canvasX = _this18._coordinateService._terminal2canvas('x', event.clientX);

            var _canvasY = _this18._coordinateService._terminal2canvas('y', event.clientY);

            var _newWidth = _canvasX - _this18._dragGroup.left;

            var _newHeight = _canvasY - _this18._dragGroup.top;

            _this18._dragGroup.setSize(_newWidth, _newHeight);
          }
        }
      };

      var mouseEndEvent = function mouseEndEvent(event) {
        var LEFT_BUTTON = 0;

        if (event.button !== LEFT_BUTTON) {
          return;
        }

        var _unionNodes = [];

        _unActiveLinkableEndpoint(); // 处理线条的问题


        if (_this18._dragType === 'endpoint:drag' && _this18._dragEdges && _this18._dragEdges.length !== 0) {
          // 释放对应画布上的x,y
          var x = _this18._coordinateService._terminal2canvas('x', event.clientX);

          var y = _this18._coordinateService._terminal2canvas('y', event.clientY);

          var _targetEndpoint = null;

          var _nodes = _$c.concat(_this18.nodes, _this18.groups);

          _nodes.forEach(function (_node) {
            if (_node.endpoints) {
              _node.endpoints.forEach(function (_point) {
                var _maxX = _point._posLeft + _point._width + (_$c.get(_point, 'expandArea.right') || _this18.theme.endpoint.expandArea.right);

                var _maxY = _point._posTop + _point._height + (_$c.get(_point, 'expandArea.bottom') || _this18.theme.endpoint.expandArea.bottom);

                var _minX = _point._posLeft - (_$c.get(_point, 'expandArea.left') || _this18.theme.endpoint.expandArea.left);

                var _minY = _point._posTop - (_$c.get(_point, 'expandArea.top') || _this18.theme.endpoint.expandArea.top);

                if (x > _minX && x < _maxX && y > _minY && y < _maxY) {
                  _targetEndpoint = _point;
                }
              });
            }
          });

          var isDestoryEdges = false; // 找不到点 或者 目标节点不是target

          if (!_targetEndpoint || _targetEndpoint.type === 'source' || _targetEndpoint._tmpType === 'source') {
            isDestoryEdges = true;
          } // scope不同


          if (!isDestoryEdges) {
            isDestoryEdges = _$c.some(_this18._dragEdges, function (edge) {
              return !ScopeCompare(edge.sourceEndpoint.scope, _targetEndpoint.scope, _$c.get(_this18, 'global.isScopeStrict'));
            });
          } // 检查endpoint限制连接数目


          if (_targetEndpoint && _targetEndpoint.limitNum !== undefined) {
            var _linkNum = _this18.edges.filter(function (_edge) {
              return _edge.targetEndpoint.id === _targetEndpoint.id;
            }).length + _this18._dragEdges.length;

            if (_linkNum > _targetEndpoint.limitNum) {
              console.warn("id\u4E3A".concat(_targetEndpoint.id, "\u7684\u951A\u70B9\u9650\u5236\u4E86").concat(_targetEndpoint.limitNum, "\u6761\u8FDE\u7EBF"));
              isDestoryEdges = true;
            }
          }

          if (isDestoryEdges) {
            _this18._dragEdges.forEach(function (edge) {
              if (edge._isDeletingEdge) {
                _this18.removeEdge(edge);
              } else {
                edge.destroy(!edge._isDeletingEdge);
              }
            }); // 把endpoint重新赋值


            _this18._dragEdges.forEach(function (_rmEdge) {
              if (_$c.get(_rmEdge, 'sourceEndpoint._tmpType') === 'source') {
                var isExistEdge = _$c.some(_this18.edges, function (edge) {
                  return _rmEdge.sourceNode.id === edge.sourceNode.id && _rmEdge.sourceEndpoint.id === edge.sourceEndpoint.id;
                });

                !isExistEdge && (_rmEdge.sourceEndpoint._tmpType = undefined);
              }

              if (_$c.get(_rmEdge, 'targetEndpoint._tmpType') === 'target') {
                var _isExistEdge2 = _$c.some(_this18.edges, function (edge) {
                  return _rmEdge.targetNode.id === edge.targetNode.id && _rmEdge.targetEndpoint.id === edge.targetEndpoint.id;
                });

                !_isExistEdge2 && (_rmEdge.targetEndpoint._tmpType = undefined);
              }
            });
          } else {
            var _delEdges = [];
            var _reconnectInfo = [];

            var _emitEdges = _this18._dragEdges.filter(function (edge) {
              // 线条去重
              if (!_this18.theme.edge.isRepeat) {
                var _isRepeat = _$c.some(_this18.edges, function (_edge) {
                  var _result = false;

                  if (edge.sourceNode) {
                    if (_edge.type === 'node') {
                      _result = edge.sourceNode.id === _edge.sourceNode.id;
                    } else {
                      _result = edge.sourceNode.id === _edge.sourceNode.id && edge.sourceEndpoint.id === _edge.sourceEndpoint.id;
                    }
                  }

                  if (_targetEndpoint.nodeId) {
                    if (_edge.type === 'node') {
                      _result = _result && _$c.get(edge, 'targetNode.id') === _$c.get(_edge, 'targetNode.id');
                    } else {
                      _result = _result && _targetEndpoint.nodeId === _$c.get(_edge, 'targetNode.id') && _targetEndpoint.id === _$c.get(_edge, 'targetEndpoint.id');
                    }
                  }

                  if (_result && edge._isDeletingEdge) {
                    _result = false;
                  }

                  return _result;
                });

                if (_isRepeat) {
                  console.warn("id\u4E3A".concat(edge.sourceEndpoint.id, "-").concat(_targetEndpoint.id, "\u7684\u7EBF\u6761\u8FDE\u63A5\u91CD\u590D\uFF0C\u8BF7\u68C0\u67E5"));
                  edge.destroy();
                  return false;
                }
              }

              var _preTargetNodeId = _$c.get(edge, 'targetNode.id');

              var _preTargetPointId = _$c.get(edge, 'targetEndpoint.id');

              var _currentTargetNode = _targetEndpoint.nodeType === 'node' ? _this18.getNode(_targetEndpoint.nodeId) : _this18.getGroup(_targetEndpoint.nodeId);

              var _currentTargetEndpoint = _targetEndpoint;

              if (_preTargetNodeId && _preTargetPointId && "".concat(_preTargetNodeId, "||").concat(_preTargetPointId) !== "".concat(_currentTargetNode.id, "||").concat(_currentTargetEndpoint.id)) {
                _delEdges.push(_$c.cloneDeep(edge));

                _reconnectInfo.push({
                  edge: edge,
                  preTargetNodeId: _preTargetNodeId,
                  preTargetPointId: _preTargetPointId,
                  currentTargetNodeId: _currentTargetNode.id,
                  currentTargetPointId: _currentTargetEndpoint.id
                });
              }

              edge._create({
                id: edge.id && !edge._isDeletingEdge ? edge.id : "".concat(edge.sourceEndpoint.id, "-").concat(_targetEndpoint.id),
                targetNode: _currentTargetNode,
                _targetType: _targetEndpoint.nodeType,
                targetEndpoint: _currentTargetEndpoint,
                type: 'endpoint'
              });

              var _isConnect = edge.isConnect ? edge.isConnect() : true;

              if (!_isConnect) {
                console.warn("id\u4E3A".concat(edge.sourceEndpoint.id, "-").concat(_targetEndpoint.id, "\u7684\u7EBF\u6761\u65E0\u6CD5\u8FDE\u63A5\uFF0C\u8BF7\u68C0\u67E5"));
                edge.destroy();
                return false;
              } // 正在删除的线重新连接


              if (edge._isDeletingEdge) {
                delete edge._isDeletingEdge;
              } else {
                edge.mounted && edge.mounted();

                _this18.edges.push(edge);
              } // 把endpoint重新赋值


              if (edge.type === 'endpoint' && !_$c.get(edge, 'sourceEndpoint.type') && !_$c.get(edge, 'sourceEndpoint._tmpType')) {
                edge.sourceEndpoint._tmpType = 'source';
              }

              if (edge.type === 'endpoint' && !_$c.get(edge, 'targetEndpoint.type') && !_$c.get(edge, 'targetEndpoint._tmpType')) {
                edge.targetEndpoint._tmpType = 'target';
              }

              return edge;
            });

            if (_delEdges.length !== 0 && _emitEdges.length !== 0) {
              _this18.pushActionQueue({
                type: 'system:reconnectEdges',
                data: {
                  delLinks: _delEdges,
                  addLinks: _emitEdges,
                  info: _reconnectInfo
                }
              });

              _this18.emit('system.link.reconnect', {
                delLinks: _delEdges,
                addLinks: _emitEdges,
                info: _reconnectInfo
              });

              _this18.emit('events', {
                type: 'link:reconnect',
                delLinks: _delEdges,
                addLinks: _emitEdges,
                info: _reconnectInfo
              });
            } else {
              if (_delEdges.length !== 0) {
                _delEdges.forEach(function (_edge) {
                  _this18.pushActionQueue({
                    type: 'system:removeEdges',
                    data: _delEdges
                  });

                  _this18.emit('system.link.delete', {
                    link: _edge
                  });

                  _this18.emit('events', {
                    type: 'link:delete',
                    link: _edge
                  });
                });
              }

              if (_emitEdges.length !== 0) {
                _this18.pushActionQueue({
                  type: 'system:addEdges',
                  data: _this18._dragEdges
                });

                _this18.emit('system.link.connect', {
                  links: _this18._dragEdges
                });

                _this18.emit('events', {
                  type: 'link:connect',
                  links: _this18._dragEdges
                });
              }
            }
          }
        }

        if (_this18._dragType === 'node:drag' && _this18._dragNode) {
          var _handleDragNode = function _handleDragNode(dragNode) {
            var sourceGroup = null;
            var targetGroup = null;
            var _nodeLeft = dragNode.left;

            var _nodeRight = dragNode.left + dragNode.getWidth();

            var _nodeTop = dragNode.top;

            var _nodeBottom = dragNode.top + dragNode.getHeight();

            if (dragNode.group) {
              var _group = _this18.getGroup(dragNode.group);

              var _groupLeft = _group.left;
              var _groupTop = _group.top;

              if (_nodeRight < 0 || _nodeLeft > _group.getWidth() || _nodeBottom < 0 || _nodeTop > _group.getHeight()) {
                _nodeLeft += _groupLeft;
                _nodeTop += _groupTop;
                _nodeRight += _groupLeft;
                _nodeBottom += _groupTop;
                sourceGroup = _group;
              } else {
                sourceGroup = _group;
                targetGroup = _group;
              }
            }

            if (!targetGroup) {
              for (var i = 0; i < _this18.groups.length; i++) {
                var _group2 = _this18.groups[i];
                var _groupLeft2 = _group2.left;

                var _groupRight = _group2.left + _group2.getWidth();

                var _groupTop2 = _group2.top;

                var _groupBottom = _group2.top + _group2.getHeight();

                if (_groupLeft2 <= _nodeLeft && _groupRight >= _nodeRight && _groupTop2 <= _nodeTop && _groupBottom >= _nodeBottom) {
                  if (_group2.id !== dragNode.group) {
                    targetGroup = _group2;
                    break;
                  }
                }
              }
            }

            var neighborEdges = []; // 更新edge里面的字段，以防外面操作了里面dom

            var _updateNeighborEdge = function _updateNeighborEdge(node, neighborEdges) {
              neighborEdges.forEach(function (_edge) {
                if (_edge.sourceNode.id === node.id) {
                  _edge.sourceNode = node;

                  var _sourceEndpoint = _$c.find(_edge.sourceNode.endpoints, function (_point) {
                    return _edge.sourceEndpoint.id === _point.id;
                  });

                  _edge.sourceEndpoint = _sourceEndpoint;
                }

                if (_edge.targetNode.id === node.id) {
                  _edge.targetNode = node;

                  var _targetEndpoint2 = _$c.find(_edge.targetNode.endpoints, function (_point) {
                    return _edge.targetEndpoint.id === _point.id;
                  });

                  _edge.targetEndpoint = _targetEndpoint2;
                }
              });
            };

            if (sourceGroup) {
              // 从源组拖动到目标组
              if (sourceGroup !== targetGroup) {
                var rmItem = _this18.removeNode(dragNode.id, true, true);

                var rmNode = rmItem.nodes[0];
                neighborEdges = rmItem.edges;
                var nodeData = {
                  id: rmNode.id,
                  top: _nodeTop,
                  left: _nodeLeft,
                  dom: rmNode.dom,
                  _isDeleteGroup: true
                };
                var step = _this18.actionQueue[_this18.actionQueueIndex];

                if (step.type === 'system:moveNodes') {
                  step.data._isDraging = true;
                }

                _this18.pushActionQueue({
                  type: 'system:groupRemoveMembers',
                  data: {
                    group: sourceGroup,
                    nodes: [rmNode],
                    _isDraging: true
                  }
                });

                _this18.emit('events', {
                  type: 'system.group.removeMembers',
                  group: sourceGroup,
                  nodes: [rmNode]
                });

                _this18.emit('system.group.removeMembers', {
                  group: sourceGroup,
                  nodes: [rmNode]
                });

                if (targetGroup) {
                  if (ScopeCompare(dragNode.scope, targetGroup.scope, _$c.get(_this18, 'global.isScopeStrict'))) {
                    nodeData.top -= targetGroup.top;
                    nodeData.left -= targetGroup.left;
                    nodeData.group = targetGroup.id;
                    nodeData._isDeleteGroup = false;

                    _this18.popActionQueue();

                    _this18.pushActionQueue({
                      type: 'system:groupAddMembers',
                      data: {
                        sourceGroup: sourceGroup,
                        targetGroup: targetGroup,
                        nodes: [rmNode],
                        _isDraging: true
                      }
                    });

                    _this18.emit('events', {
                      type: 'system.group.addMembers',
                      nodes: [rmNode],
                      group: targetGroup
                    });

                    _this18.emit('system.group.addMembers', {
                      nodes: [rmNode],
                      group: targetGroup
                    });
                  } else {
                    console.warn("nodeId\u4E3A".concat(dragNode.id, "\u7684\u8282\u70B9\u548CgroupId").concat(targetGroup.id, "\u7684\u8282\u70B9\u7EC4scope\u503C\u4E0D\u7B26\uFF0C\u65E0\u6CD5\u52A0\u5165"));
                  }
                }

                rmNode._init(nodeData);

                _this18.addNode(rmNode, true);

                _updateNeighborEdge(rmNode, neighborEdges);
              }
            } else {
              if (targetGroup) {
                if (ScopeCompare(dragNode.scope, targetGroup.scope, _$c.get(_this18, 'global.isScopeStrict'))) {
                  var _rmItem = _this18.removeNode(dragNode.id, true, true);

                  var _rmNode = _rmItem.nodes[0];
                  neighborEdges = _rmItem.edges;

                  _rmNode._init({
                    top: _nodeTop - targetGroup.top,
                    left: _nodeLeft - targetGroup.left,
                    dom: _rmNode.dom,
                    group: targetGroup.id
                  });

                  _this18.addNode(_rmNode, true);

                  var _step3 = _this18.actionQueue[_this18.actionQueueIndex];

                  if (_step3.type === 'system:moveNodes') {
                    _step3.data._isDraging = true;
                  }

                  _updateNeighborEdge(_rmNode, neighborEdges);

                  _this18.pushActionQueue({
                    type: 'system:groupAddMembers',
                    data: {
                      sourceGroup: undefined,
                      targetGroup: targetGroup,
                      nodes: [_rmNode],
                      _isDraging: true
                    }
                  });

                  _this18.emit('events', {
                    type: 'system.group.addMembers',
                    nodes: [_rmNode],
                    group: targetGroup
                  });

                  _this18.emit('system.group.addMembers', {
                    nodes: [_rmNode],
                    group: targetGroup
                  });
                } else {
                  console.warn("nodeId\u4E3A".concat(dragNode.id, "\u7684\u8282\u70B9\u548CgroupId").concat(targetGroup.id, "\u7684\u8282\u70B9\u7EC4scope\u503C\u4E0D\u7B26\uFF0C\u65E0\u6CD5\u52A0\u5165"));
                }
              }
            }

            neighborEdges.forEach(function (item) {
              item.redraw();
            });
            dragNode.endpoints.forEach(function (item) {
              item.updatePos && item.updatePos();
            });
            dragNode._isMoving = false;
          };

          var moveNodes = [_this18._dragNode];

          var unionKeys = _this18._findUnion('nodes', _this18._dragNode);

          if (unionKeys && unionKeys.length > 0) {
            unionKeys.forEach(function (key) {
              moveNodes = moveNodes.concat(_this18._unionData[key].nodes);
            });
            moveNodes = _$c.uniqBy(moveNodes, 'id');
          }

          moveNodes.forEach(function (dragNode) {
            _handleDragNode(dragNode);
          });
          _unionNodes = moveNodes;

          _this18._rmSystemUnion();
        } // 节点组放大缩小


        if (_this18._dragType === 'group:resize' && _this18._dragGroup) {
          _this18.emit('events', {
            type: 'system.group.resize',
            group: _this18._dragGroup
          });

          _this18.emit('system.group.resize', {
            group: _this18._dragGroup
          });
        } // 点击空白处触发canvas click，并且框选模式下不触发


        if ((_this18._dragType === 'canvas:drag' || !_this18._dragType) && !_this18.isSelectMode) {
          _this18.emit('system.canvas.click');

          _this18.emit('events', {
            type: 'canvas:click'
          });
        }

        if (_this18._dragType === 'node:drag' || _this18._dragType === 'group:drag') {
          _this18.pushActionQueue({
            type: '_system:dragNodeEnd'
          });
        }

        _this18.emit('system.drag.end', {
          dragType: _this18._dragType,
          dragNode: _this18._dragNode,
          dragEndpoint: _this18._dragEndpoint,
          dragEdges: _this18._dragEdges,
          dragGroup: _this18._dragGroup,
          unionNodes: _unionNodes
        });

        _this18.emit('events', {
          type: 'drag:end',
          dragType: _this18._dragType,
          dragNode: _this18._dragNode,
          dragEndpoint: _this18._dragEndpoint,
          dragEdges: _this18._dragEdges,
          dragGroup: _this18._dragGroup,
          unionNodes: _unionNodes
        });

        _this18._dragType = null;
        _this18._dragNode = null;
        _this18._dragEndpoint = null;
        _this18._dragGroup = null;
        _this18._dragEdges = [];
        nodeOriginPos = {
          x: 0,
          y: 0
        };
        canvasOriginPos = {
          x: 0,
          y: 0
        };
        _this18._autoMoveDir = [];
        _this18._guidelineService.isActive && _this18._guidelineService.clearCanvas();
      };

      this.root.addEventListener('mousedown', mouseDownEvent);
      this.root.addEventListener('mousemove', mouseMoveEvent); // this.root.addEventListener('mouseleave', mouseEndEvent);

      this.root.addEventListener('mouseup', mouseEndEvent);
    }
  }, {
    key: "_autoMoveCanvas",
    value: function _autoMoveCanvas(x, y, data, cb) {
      var _this19 = this;

      if (!this.theme.autoFixCanvas.enable) {
        return;
      }

      this._autoMoveDir = [];
      var _terOffsetX = this._coordinateService.terOffsetX;
      var _terOffsetY = this._coordinateService.terOffsetY;
      clearInterval(this._autoMoveTimer);
      this._autoMoveTimer = null;

      if (this._autoMoveTimer && this._autoMoveDir.length > 0) {
        return;
      }

      var _autoMovePadding = this.theme.autoFixCanvas.autoMovePadding;

      if (x - _terOffsetX <= _autoMovePadding[3]) {
        this._autoMoveDir.push('left');
      }

      if (this._rootWidth - (x - _terOffsetX) <= _autoMovePadding[1]) {
        this._autoMoveDir.push('right');
      }

      if (y - _terOffsetY <= _autoMovePadding[0]) {
        this._autoMoveDir.push('top');
      }

      if (this._rootHeight - (y - _terOffsetY) <= _autoMovePadding[2]) {
        this._autoMoveDir.push('bottom');
      }

      if (this._autoMoveDir.length === 0) {
        clearInterval(this._autoMoveTimer);
        return;
      }

      if (!this._autoMoveTimer) {
        var MOVE_GAP = 5;
        this._autoMoveTimer = setInterval(function () {
          if (_this19._autoMoveDir.includes('left')) {
            _this19.move([_this19._moveData[0] + MOVE_GAP, _this19._moveData[1]]);

            _moveTarget([-MOVE_GAP, 0]);
          }

          if (_this19._autoMoveDir.includes('right')) {
            _this19.move([_this19._moveData[0] - MOVE_GAP, _this19._moveData[1]]);

            _moveTarget([+MOVE_GAP, 0]);
          }

          if (_this19._autoMoveDir.includes('top')) {
            _this19.move([_this19._moveData[0], _this19._moveData[1] + MOVE_GAP]);

            _moveTarget([0, -MOVE_GAP]);
          }

          if (_this19._autoMoveDir.includes('bottom')) {
            _this19.move([_this19._moveData[0], _this19._moveData[1] - MOVE_GAP]);

            _moveTarget([0, +MOVE_GAP]);
          }
        }, 70);
      } // 同时需要移动target


      var _moveTarget = function _moveTarget(gap) {
        if (data.type === 'node:drag') {
          data.nodes.forEach(function (item) {
            item.moveTo(item.left + gap[0], item.top + gap[1]);
          });
        } else if (data.type === 'group:drag') {
          var group = data.group;
          group.moveTo(group.left + gap[0], group.top + gap[1]);
        }

        cb && cb(gap);
      };
    }
  }, {
    key: "_moveNode",
    value: function _moveNode(node, x, y, isNotEventEmit) {
      if (!isNotEventEmit) {
        this.pushActionQueue({
          type: 'system:moveNodes',
          data: {
            node: node,
            top: y,
            left: x
          }
        });
      }

      node._moveTo(x, y);

      this.edges.forEach(function (edge) {
        if (edge.type === 'endpoint') {
          var isLink = _$c.find(node.endpoints, function (point) {
            return point.nodeId === edge.sourceNode.id && !!edge.sourceNode.getEndpoint(point.id, 'source') || point.nodeId === edge.targetNode.id && !!edge.targetNode.getEndpoint(point.id, 'target');
          });

          isLink && edge.redraw();
        } else if (edge.type === 'node') {
          var _isLink = edge.sourceNode.id === node.id || edge.targetNode.id === node.id;

          _isLink && edge.redraw();
        }
      });
    }
  }, {
    key: "_moveGroup",
    value: function _moveGroup(group, x, y, isNotEventEmit) {
      if (!isNotEventEmit) {
        this.pushActionQueue({
          type: 'system:moveGroups',
          data: {
            group: group,
            top: y,
            left: x
          }
        });
      }

      group._moveTo(x, y);

      this.edges.forEach(function (edge) {
        var hasUpdate = _$c.get(edge, 'sourceNode.group') === group.id || _$c.get(edge, 'targetNode.group') === group.id || _$c.get(edge, '_sourceType') === 'group' && _$c.get(edge, 'sourceNode.id') === group.id || _$c.get(edge, '_targetType') === 'group' && _$c.get(edge, 'targetNode.id') === group.id;
        hasUpdate && edge.redraw();
      });
    }
  }, {
    key: "_autoLayout",
    value: function _autoLayout(data) {
      var width = this._rootWidth;
      var height = this._rootHeight;

      if (_$c.isFunction(this.layout)) {
        this.layout({
          width: width,
          height: height,
          data: data
        });
      } else {
        // 重力布局
        if (_$c.get(this.layout, 'type') === 'forceLayout') {
          var _opts = $$9.extend({
            // 布局画布总宽度
            width: width,
            // 布局画布总长度
            height: height,
            // 布局相对中心点
            center: {
              x: width / 2,
              y: height / 2
            },
            // 节点互斥力，像电荷原理一样
            chargeStrength: -150,
            link: {
              // 以node的什么字段为寻找id，跟d3原理一样
              id: 'id',
              // 线条的距离
              distance: 200,
              // 线条的粗细
              strength: 1
            }
          }, _$c.get(this.layout, 'options'), true); // 自动布局


          if (_$c.get(this.layout, 'type') === 'forceLayout') {
            Layout$1.forceLayout({
              opts: _opts,
              data: {
                groups: data.groups,
                nodes: data.nodes,
                // 加工线条数据，兼容endpoint为id的属性，d3没这个概念
                edges: data.edges.map(function (item) {
                  return {
                    source: item.type === 'endpoint' ? item.sourceNode : item.source,
                    target: item.type === 'endpoint' ? item.targetNode : item.target
                  };
                })
              }
            });
          }
        } else if (_$c.get(this.layout, 'type') === 'drageLayout') {
          Layout$1.drageLayout({
            //  /** layout 方向, 可选 TB, BT, LR, RL */
            // public rankdir: 'TB' | 'BT' | 'LR' | 'RL' = 'TB';
            rankdir: _$c.get(this.layout, 'options.rankdir') || 'TB',
            // /** 节点对齐方式，可选 UL, UR, DL, DR */
            // public align: undefined | 'UL' | 'UR' | 'DL' | 'DR';
            align: _$c.get(this.layout, 'options.align'),
            // /** 节点大小 */
            // public nodeSize: number | number[] | undefined;
            nodeSize: _$c.get(this.layout, 'options.nodeSize'),
            // /** 节点水平间距(px) */
            // public nodesepFunc: ((d?: any) => number) | undefined;
            nodesepFunc: _$c.get(this.layout, 'options.nodesepFunc'),
            // /** 每一层节点之间间距 */
            // public ranksepFunc: ((d?: any) => number) | undefined;
            ranksepFunc: _$c.get(this.layout, 'options.ranksepFunc'),
            // /** 节点水平间距(px) */
            // public nodesep: number = 50;
            nodesep: _$c.get(this.layout, 'options.nodesep') || 50,
            // /** 每一层节点之间间距 */
            // public ranksep: number = 50;
            ranksep: _$c.get(this.layout, 'options.ranksep') || 50,
            // /** 是否保留布局连线的控制点 */
            // public controlPoints: boolean = false;
            controlPoints: _$c.get(this.layout, 'options.controlPoints') || false,
            data: {
              // groups: data.groups,
              nodes: data.nodes,
              edges: data.edges.map(function (item) {
                return {
                  source: item.type === 'endpoint' ? item.sourceNode : item.source,
                  target: item.type === 'endpoint' ? item.targetNode : item.target
                };
              })
            }
          });
        } else if (_$c.get(this.layout, 'type') === 'concentricLayout') {
          Layout$1.concentLayout({
            /** 布局中心 默认值：图的中心 */
            // public center: [number, number];
            center: _$c.get(this.layout, 'options.center') || [width / 2, height / 2],
            // /** 节点大小（直径）。用于防止节点重叠时的碰撞检测 */
            // public nodeSize: number | [number, number] = 30;
            nodeSize: _$c.get(this.layout, 'options.nodeSize') || 30,
            // /** 环与环之间最小间距，用于调整半径 */
            // public minNodeSpacing: number = 10;
            minNodeSpacing: _$c.get(this.layout, 'options.minNodeSpacing') || 10,
            // /** 是否防止重叠，必须配合上面属性 nodeSize，只有设置了与当前图节点大小相同的 nodeSize 值，才能够进行节点重叠的碰撞检测 */
            // public preventOverlap: boolean = false;
            preventOverlap: _$c.get(this.layout, 'options.preventOverlap') || false,
            // /** 第一个节点与最后一个节点之间的弧度差。若为 undefined ，则将会被设置为  2 _ Math.PI _ (1 - 1 / |level.nodes|) ，其中 level.nodes 为该算法计算出的每一层的节点，|level.nodes| 代表该层节点数量 */
            // public sweep: number | undefined;
            sweep: _$c.get(this.layout, 'options.sweep'),
            // /** 环与环之间的距离是否相等 */
            // public equidistant: boolean = false;
            equidistant: _$c.get(this.layout, 'options.equidistant') || false,
            // /** 开始方式节点的弧度 */
            // public startAngle: number = (3 / 2) * Math.PI;
            startAngle: 3 / 2 * Math.PI,
            // /** 是否按照顺时针排列 */
            // public clockwise: boolean = true;
            clockwise: _$c.get(this.layout, 'options.clockwise') || true,
            // /** 每一层同心值的求和。若为 undefined，则将会被设置为 maxValue / 4 ，其中 maxValue 为最大的排序依据的属性值。例如，若 sortBy 为 'degree'，则 maxValue 为所有节点中度数最大的节点的度数 */
            //public maxLevelDiff: undefined | number;
            maxLevelDiff: _$c.get(this.layout, 'options.maxLevelDiff'),
            // /** 指定排序的依据（节点属性名），数值越高则该节点被放置得越中心。若为 undefined，则会计算节点的度数，度数越高，节点将被放置得越中心 */
            // public sortBy: string = 'degree';
            sortBy: _$c.get(this.layout, 'options.sortBy') || 'degree',
            // 布局画布总宽度
            width: width,
            // 布局画布总长度
            height: height,
            data: {
              groups: data.groups,
              nodes: data.nodes,
              edges: data.edges.map(function (item) {
                return {
                  source: item.type === 'endpoint' ? item.sourceNode : item.source,
                  target: item.type === 'endpoint' ? item.targetNode : item.target
                };
              })
            }
          });
        } else if (_$c.get(this.layout, 'type') === 'circleLayout') {
          Layout$1.circleLayout({
            radius: _$c.get(this.layout, 'options.radius'),
            getWidth: _$c.get(this.layout, 'options.getWidth'),
            getHeight: _$c.get(this.layout, 'options.getHeight'),
            data: {
              nodes: data.nodes,
              edges: data.edges.map(function (item) {
                return {
                  source: item.type === 'endpoint' ? item.sourceNode : item.source,
                  target: item.type === 'endpoint' ? item.targetNode : item.target
                };
              })
            }
          });
        } else if (_$c.get(this.layout, 'type') === 'gridLayout') {
          var _opts2 = $$9.extend({
            // 布局画布总宽度
            width: 150,
            // 布局画布总长度
            height: 100,
            // 布局相对起始点
            begin: [0, 0],
            preventOverlap: true,
            preventOverlapPadding: 10,
            condense: false,
            //宽高
            rows: undefined,
            cols: undefined,
            //位置
            position: undefined,
            // 排序方式
            sortBy: 'degree',
            nodeSize: 30,
            link: {
              // 以node的什么字段为寻找id，跟d3原理一样
              id: 'id',
              // 线条的距离
              distance: 100,
              // 线条的粗细
              strength: 1
            }
          }, _$c.get(this.layout, 'options'), true); // 自动布局


          if (_$c.get(this.layout, 'type') === 'gridLayout') {
            Layout$1.gridLayout({
              opts: _opts2,
              data: {
                groups: data.groups,
                nodes: data.nodes,
                // 加工线条数据，兼容endpoint为id的属性，d3没这个概念
                edges: data.edges.map(function (item) {
                  return {
                    source: item.type === 'endpoint' ? item.sourceNode : item.source,
                    target: item.type === 'endpoint' ? item.targetNode : item.target
                  };
                })
              }
            });
          }
        } else if (_$c.get(this.layout, 'type') === 'fruchterman') {
          var _opts3 = $$9.extend({
            // 布局画布总宽度
            width: width,
            // 布局画布总长度
            height: height,

            /** 停止迭代的最大迭代数 */
            maxIteration: 1000,

            /** 布局中心 */
            center: [width / 2, height / 2],

            /** 重力大小，影响图的紧凑程度 */
            gravity: 5,

            /** 速度 */
            speed: 5,

            /** 是否产生聚类力 */
            clustering: false,

            /** 聚类力大小 */
            clusterGravity: 10,
            link: {
              // 以node的什么字段为寻找id，跟d3原理一样
              id: 'id',
              // 线条的距离
              distance: 100,
              // 线条的粗细
              strength: 1
            }
          }, _$c.get(this.layout, 'options'), true); // 自动布局


          if (_$c.get(this.layout, 'type') === 'fruchterman') {
            Layout$1.fruchterman({
              opts: _opts3,
              data: {
                groups: data.groups,
                nodes: data.nodes,
                // 加工线条数据，兼容endpoint为id的属性，d3没这个概念
                edges: data.edges.map(function (item) {
                  return {
                    source: item.type === 'endpoint' ? item.sourceNode : item.source,
                    target: item.type === 'endpoint' ? item.targetNode : item.target
                  };
                })
              }
            });
          }
        }
      }
    }
  }, {
    key: "_selectMultiplyItem",
    value: function _selectMultiplyItem(range, toDirection) {
      var _this20 = this;

      // 确认一下终端的偏移值
      var startX = this._coordinateService._terminal2canvas('x', range[0]);

      var startY = this._coordinateService._terminal2canvas('y', range[1]);

      var endX = this._coordinateService._terminal2canvas('x', range[2]);

      var endY = this._coordinateService._terminal2canvas('y', range[3]);

      var includeNode = _$c.includes(this.selecContents, 'node');

      var includeEdge = _$c.includes(this.selecContents, 'edge');

      var includeEndpoint = _$c.includes(this.selecContents, 'endpoint');

      var _isSelected = function _isSelected(option) {
        var _itemLeft = option.left;
        var _itemRight = option.right;
        var _itemTop = option.top;
        var _itemBottom = option.bottom;

        if (_this20.selecMode === 'include' || _this20.selecMode === 'senior' && toDirection === 'right') {
          return startX < _itemLeft && endX > _itemRight && startY < _itemTop && endY > _itemBottom;
        }

        if (_this20.selecMode === 'touch' || _this20.selecMode === 'senior' && toDirection === 'left') {
          var result = true;

          if (endX < _itemLeft) {
            result = false;
          }

          if (startX > _itemRight) {
            result = false;
          }

          if (endY < _itemTop) {
            result = false;
          }

          if (startY > _itemBottom) {
            result = false;
          }

          return result;
        }
      }; // 框选节点


      if (includeNode) {
        this.nodes.forEach(function (item) {
          var nodeLeft = item.left;
          var nodeRight = item.left + $$9(item.dom).width();
          var nodeTop = item.top;
          var nodeBottom = item.top + $$9(item.dom).height();

          if (item.group) {
            var _group = _this20.getGroup(item.group);

            nodeLeft += _group.left;
            nodeRight += _group.left;
            nodeTop += _group.top;
            nodeBottom += _group.top;
          }

          var isSelected = _isSelected({
            left: nodeLeft,
            right: nodeRight,
            top: nodeTop,
            bottom: nodeBottom
          });

          if (isSelected) {
            _this20.selectItem.nodes.push(item);
          }
        });
      } // 框选锚点


      if (includeEndpoint) {
        this.nodes.forEach(function (node) {
          node.endpoints.forEach(function (item) {
            var pointLeft = item._posLeft;
            var pointRight = item._posLeft + $$9(item.dom).width();
            var pointTop = item._posTop;
            var pointBottom = item._posTop + $$9(item.dom).height();

            var isSelected = _isSelected({
              left: pointLeft,
              right: pointRight,
              top: pointTop,
              bottom: pointBottom
            });

            if (isSelected) {
              _this20.selectItem.endpoints.push(item);
            }
          });
        });
      } // 框选线条


      if (includeEdge) {
        this.edges.forEach(function (item) {
          if (item.type === 'endpoint') {
            var left = item.sourceEndpoint._posLeft < item.targetEndpoint._posLeft ? item.sourceEndpoint._posLeft : item.targetEndpoint._posLeft;
            var right = item.sourceEndpoint._posLeft + item.sourceEndpoint._width > item.targetEndpoint._posLeft + item.targetEndpoint._width ? item.sourceEndpoint._posLeft + item.sourceEndpoint._width : item.targetEndpoint._posLeft + item.targetEndpoint._width;
            var top = item.sourceEndpoint._posTop < item.targetEndpoint._posTop ? item.sourceEndpoint._posTop : item.targetEndpoint._posTop;
            var bottom = item.sourceEndpoint._posTop + item.sourceEndpoint._height > item.targetEndpoint._posTop + item.targetEndpoint._height ? item.sourceEndpoint._posTop + item.sourceEndpoint._height : item.targetEndpoint._posTop + item.targetEndpoint._height;

            var isSelected = _isSelected({
              left: left,
              right: right,
              top: top,
              bottom: bottom
            });

            if (isSelected) {
              _this20.selectItem.edges.push(item);
            }
          } else if (item.type === 'node') ;
        });
      } // 框选节点组，准备支持


      return this.selectItem;
    }
  }, {
    key: "_getAllEndpoints",
    value: function _getAllEndpoints() {
      var points = [];
      points = points.concat(this.nodes.map(function (_node) {
        return _node.endpoints;
      }));
      points = points.concat(this.groups.map(function (_node) {
        return _node.endpoints;
      }));
      points = points.filter(function (item) {
        return !!item;
      });
      return _$c.flatten(points);
    }
  }, {
    key: "undo",
    value: function undo() {
      var _this21 = this;

      var result = [];

      if (this.actionQueueIndex <= -1) {
        console.warn('回退堆栈已空，无法再undo');
        return;
      }

      var step = this.actionQueue[this.actionQueueIndex--];

      if (step.type === '_system:dragNodeEnd') {
        step = this.actionQueue[this.actionQueueIndex--];
      }

      result.push(step);

      if (step.type === 'system:addNodes') {
        this.removeNodes(step.data, false, true);
      } else if (step.type === 'system:removeNodes') {
        this.addNodes(step.data.nodes, true);
        this.addEdges(step.data.edges, true);
      } else if (step.type === 'system:addEdges') {
        this.removeEdges(step.data, true, true);
      } else if (step.type === 'system:removeEdges') {
        this.addEdges(step.data, true);
      } else if (step.type === 'system:moveNodes') {
        for (var key in step.data.nodes) {
          var _nodeInfo = step.data.nodes[key];

          var _node = this.getNode(key);

          _node.moveTo(_nodeInfo.fromLeft, _nodeInfo.fromTop, true);
        }
      } else if (step.type === 'system:moveGroups') {
        for (var _key in step.data.groups) {
          var _groupInfo = step.data.groups[_key];

          var _group = this.getGroup(_key);

          _group.moveTo(_groupInfo.fromLeft, _groupInfo.fromTop, true);
        }
      } else if (step.type === 'system:addGroups') {
        step.data.forEach(function (item) {
          if (item.nodes.length > 0) {
            _this21.removeNodes(item.nodes);
          }

          _this21.removeGroup(item.group.id, true);
        });
      } else if (step.type === 'system:removeGroup') {
        this.addGroup(step.data.group, step.data.nodes || [], undefined, true);
      } else if (step.type === 'system:groupAddMembers') {
        var sourceGroup = step.data.sourceGroup;
        var targetGroup = step.data.targetGroup;

        if (targetGroup) {
          targetGroup.removeNodes(step.data.nodes, true);
        }

        if (sourceGroup) {
          sourceGroup.addNodes(step.data.nodes, true);
        }

        var _preStep = {};

        if (step.data._isDraging) {
          _preStep = this.actionQueue[this.actionQueueIndex];

          if (_preStep.type === 'system:moveNodes') {
            for (var _key2 in _preStep.data.nodes) {
              var _nodeInfo2 = _preStep.data.nodes[_key2];

              var _node3 = this.getNode(_key2);

              _node3.moveTo(_nodeInfo2.fromLeft, _nodeInfo2.fromTop, true);
            }

            result.unshift(_preStep);
          }
        }

        this.actionQueueIndex--;
      } else if (step.type === 'system:groupRemoveMembers') {
        var group = step.data.group;

        if (group) {
          group.addNodes(step.data.nodes, true);
        }

        var _preStep2 = {};

        if (step.data._isDraging) {
          _preStep2 = this.actionQueue[this.actionQueueIndex];

          if (_preStep2.type === 'system:moveNodes') {
            for (var _key3 in _preStep2.data.nodes) {
              var _nodeInfo3 = _preStep2.data.nodes[_key3];

              var _node4 = this.getNode(_key3);

              _node4.moveTo(_nodeInfo3.fromLeft, _nodeInfo3.fromTop, true);
            }

            result.unshift(_preStep2);
            this.actionQueueIndex--;
          }
        }

        this.actionQueueIndex--;
      } else if (step.type === 'system:reconnectEdges') {
        _$c.get(step, 'data.info', []).forEach(function (info) {
          var targetNode = _this21.getNode(info.preTargetNodeId);

          var targetEndpoint = targetNode.getEndpoint(info.preTargetPointId);

          info.edge._create({
            id: "".concat(info.edge.sourceEndpoint.id, "-").concat(targetEndpoint.id),
            targetNode: targetNode,
            _targetType: targetEndpoint.nodeType,
            targetEndpoint: targetEndpoint,
            type: 'endpoint'
          });
        });
      }

      this.emit('system.canvas.undo', {
        steps: result
      });
      this.emit('events', {
        type: 'canvas.undo',
        steps: result
      });
    }
  }, {
    key: "redo",
    value: function redo() {
      var _this22 = this;

      var result = [];

      if (this.actionQueueIndex >= this.actionQueue.length - 1) {
        console.warn('重做堆栈已到顶，无法再redo');
        return;
      }

      var step = this.actionQueue[++this.actionQueueIndex];
      result.push(step);

      if (step.type === 'system:moveNodes' && step.data._isDraging) {
        step = this.actionQueue[++this.actionQueueIndex];
        result.push(step);
      }

      if (step.type === 'system:addNodes') {
        this.addNodes(step.data, true);
      } else if (step.type === 'system:removeNodes') {
        this.removeNodes(step.data.nodes, false, true);
      } else if (step.type === 'system:addEdges') {
        this.addEdges(step.data, true);
      } else if (step.type === 'system:removeEdges') {
        this.removeEdges(step.data, true);
      } else if (step.type === 'system:moveNodes') {
        for (var key in step.data.nodes) {
          var _nodeInfo = step.data.nodes[key];

          var _node = this.getNode(key);

          _node.moveTo(_nodeInfo.toLeft, _nodeInfo.toTop, true);
        }
      } else if (step.type === 'system:moveGroups') {
        for (var _key4 in step.data.groups) {
          var _groupInfo = step.data.groups[_key4];

          var _group = this.getGroup(_key4);

          _group.moveTo(_groupInfo.toLeft, _groupInfo.toTop, true);
        }
      } else if (step.type === 'system:addGroups') {
        step.data.forEach(function (item) {
          _this22.addGroup(item.group, item.nodes || [], undefined, true);
        });
      } else if (step.type === 'system:removeGroup') {
        this.removeGroup(step.data.group, true);
      } else if (step.type === 'system:groupAddMembers') {
        var sourceGroup = step.data.sourceGroup;
        var targetGroup = step.data.targetGroup;
        var _preStep = this.actionQueue[this.actionQueueIndex - 1];

        if (_preStep.type === 'system:moveNodes' && _preStep.data._isDraging) {
          for (var _key5 in _preStep.data.nodes) {
            var _nodeInfo4 = _preStep.data.nodes[_key5];

            var _node5 = this.getNode(_key5);

            _node5.moveTo(_nodeInfo4.toLeft, _nodeInfo4.toTop, true);
          }
        }

        if (targetGroup) {
          targetGroup.addNodes(step.data.nodes, true);
        }

        if (sourceGroup) {
          sourceGroup.removeNodes(step.data.nodes, true);
        }
      } else if (step.type === 'system:groupRemoveMembers') {
        var group = step.data.group;

        if (group) {
          group.removeNodes(step.data.nodes, true);
        }

        var _preStep3 = {};

        if (step.data._isDraging) {
          _preStep3 = this.actionQueue[this.actionQueueIndex];

          if (_preStep3.type === 'system:moveNodes') {
            for (var _key6 in _preStep3.data.nodes) {
              var _nodeInfo5 = _preStep3.data.nodes[_key6];

              var _node6 = this.getNode(_key6);

              _node6.moveTo(_nodeInfo5.fromLeft, _nodeInfo5.fromTop, true);
            }

            this.actionQueueIndex--;
          }
        }
      } else if (step.type === 'system:reconnectEdges') {
        _$c.get(step, 'data.info', []).forEach(function (info) {
          var targetNode = _this22.getNode(info.currentTargetNodeId);

          var targetEndpoint = targetNode.getEndpoint(info.currentTargetPointId);

          info.edge._create({
            id: "".concat(info.edge.sourceEndpoint.id, "-").concat(targetEndpoint.id),
            targetNode: targetNode,
            _targetType: targetEndpoint.nodeType,
            targetEndpoint: targetEndpoint,
            type: 'endpoint'
          });
        });
      }

      this.emit('system.canvas.redo', {
        steps: result
      });
      this.emit('events', {
        type: 'canvas.redo',
        steps: result
      });

      if (_$c.get(this.actionQueue, [this.actionQueueIndex + 1, 'type']) === '_system:dragNodeEnd') {
        this.actionQueueIndex++;
      }
    }
  }, {
    key: "isActionQueueTop",
    value: function isActionQueueTop() {
      return this.actionQueueIndex >= this.actionQueue.length - 1;
    }
  }, {
    key: "isActionQueueBottom",
    value: function isActionQueueBottom() {
      return this.actionQueueIndex <= -1;
    }
  }, {
    key: "pushActionQueue",
    value: function pushActionQueue(option) {
      var _this23 = this;

      var step = option; //移动节点需要合并堆栈

      if (option.type === 'system:moveNodes' || option.type === 'system:moveGroups') {
        var _type = {
          'system:moveNodes': 'node',
          'system:moveGroups': 'group'
        }[option.type];

        var _types = _type + 's'; // 堆栈前一个不是moveNode


        var currentStep = this.actionQueue[this.actionQueueIndex] || {};

        if (currentStep.type === option.type && currentStep.data[_types][option.data[_type].id]) {
          currentStep.data[_types][option.data[_type].id]['toTop'] = option.data.top;
          currentStep.data[_types][option.data[_type].id]['toLeft'] = option.data.left;
          return;
        } else {
          var moveItems = [option.data[_type]];

          var unionKeys = this._findUnion(_types, option.data[_type]);

          if (unionKeys && unionKeys.length > 0) {
            unionKeys.forEach(function (key) {
              moveItems = moveItems.concat(_this23._unionData[key][_types]);
            });
            moveItems = _$c.uniqBy(moveItems, 'id');
          }

          step = {
            type: option.type,
            data: _defineProperty({}, _types, {})
          };
          moveItems.forEach(function (item) {
            step.data[_types][item.id] = {
              fromTop: item.top,
              fromLeft: item.left,
              toTop: item.top,
              toLeft: item.left
            };
          });
          step.data[_types][option.data[_type].id]['toTop'] = option.data.top;
          step.data[_types][option.data[_type].id]['toLeft'] = option.data.left;
        }
      } // 堆栈满了，清理


      if (this.actionQueueIndex >= this.global.limitQueueLen) {
        this.actionQueue.shift();
        this.actionQueueIndex--;
      } // 把index前的步骤覆盖掉


      this.actionQueue.splice(this.actionQueueIndex + 1, this.actionQueue.length); // todo可能有问题

      this.actionQueue.push(step);
      this.actionQueueIndex++;

      if (_$c.get(this.actionQueue, [this.actionQueueIndex - 1, 'type']) === '_system:dragNodeEnd') {
        this.actionQueue.splice(this.actionQueueIndex - 1, 1);
        this.actionQueueIndex--;
      }
    }
  }, {
    key: "popActionQueue",
    value: function popActionQueue() {
      if (this.actionQueue.length > 0) {
        var action = this.actionQueue.pop();
        return action;
      } else {
        console.warn('操作队列已为空，请确认');
      }
    }
  }, {
    key: "clearActionQueue",
    value: function clearActionQueue() {
      this.actionQueue = [];
      this.actionQueueIndex = -1;
    }
  }]);

  return BaseCanvas;
}(Canvas);

var TreeNode = /*#__PURE__*/function (_Node) {
  _inherits(TreeNode, _Node);

  var _super = _createSuper(TreeNode);

  function TreeNode(options) {
    var _this;

    _classCallCheck(this, TreeNode);

    _this = _super.call(this, options);
    _this.children = options.children;
    _this.parent = options.parent;
    _this.collapsed = options.collapsed || false;

    if (options.isRoot) {
      _this.isRoot = options.isRoot;
    }

    return _this;
  }

  _createClass(TreeNode, [{
    key: "collapse",
    value: function collapse() {
      this._emit('InnerEvents', {
        type: 'node:collapse',
        nodeId: this.id
      });

      this.collapsed = true;
    }
  }, {
    key: "expand",
    value: function expand() {
      var nodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      this._emit('InnerEvents', {
        type: 'node:expand',
        nodeId: this.id,
        nodes: nodes
      });

      delete this.collapsed;
    }
  }, {
    key: "detectLeaf",
    value: function detectLeaf() {
      return !!!(this.children && this.children.length > 0);
    }
  }, {
    key: "detectRoot",
    value: function detectRoot() {
      return this.isRoot;
    }
  }]);

  return TreeNode;
}(BaseNode);

var Hierarchy = require('@antv/hierarchy');

function tranlateData(data) {
  var queue = [data];
  var nodeList = [];

  while (queue.length > 0) {
    var node = queue.pop();
    var newNode = node.data;
    newNode.left = node.x;
    newNode.top = node.y;
    newNode.treePos = {
      hgap: node.hgap,
      vgap: node.vgap,
      x: node.x,
      y: node.y,
      depth: node.depth,
      side: node.side
    };
    nodeList.push(newNode);
    queue = queue.concat(node.children);
  }

  return nodeList[0];
}

var Hierarchy$1 = {
  compactBox: function compactBox(data, options) {
    return tranlateData(Hierarchy.compactBox(data, options));
  },
  dendrogram: function dendrogram(data, options) {
    return tranlateData(Hierarchy.dendrogram(data, options));
  },
  indented: function indented(data, options) {
    return tranlateData(Hierarchy.indented(data, options));
  },
  mindmap: function mindmap(data, options) {
    return tranlateData(Hierarchy.mindmap(data, options));
  }
};

var _$d = require('lodash');

var TreeCanvas = /*#__PURE__*/function (_Canvas) {
  _inherits(TreeCanvas, _Canvas);

  var _super = _createSuper(TreeCanvas);

  function TreeCanvas(options) {
    var _this;

    _classCallCheck(this, TreeCanvas);

    _this = _super.call(this, options);
    _this._NodeClass = TreeNode;
    return _this;
  }

  _createClass(TreeCanvas, [{
    key: "_handleTreeNodes",
    value: function _handleTreeNodes(data, isFlat) {
      if (isFlat) {
        return data;
      } else {
        var queue = [data];
        var nodeList = [];

        var _loop = function _loop() {
          var node = queue.pop();
          nodeList.push(node);

          if (node.children && node.children.length > 0) {
            node.children.forEach(function (child) {
              child.parent = node.id;
            });
            queue = queue.concat(node.children);
          }
        };

        while (queue.length > 0) {
          _loop();
        }

        return nodeList;
      }
    }
  }, {
    key: "_isExistNode",
    value: function _isExistNode(node) {
      var result = _get(_getPrototypeOf(TreeCanvas.prototype), "_isExistNode", this).call(this, node);

      if (result && node.subCollapsed) {
        result = false;
      }

      return;
    }
  }, {
    key: "_addEventListener",
    value: function _addEventListener() {
      var _this2 = this;

      _get(_getPrototypeOf(TreeCanvas.prototype), "_addEventListener", this).call(this);

      this.on('InnerEvents', function (data) {
        if (data.type === 'node:collapse') {
          _this2.collapseNode(data.nodeId);
        } else if (data.type == 'node:expand') {
          _this2.expandNode(data.nodeId);
        }
      });
    }
  }, {
    key: "findSubTree",
    value: function findSubTree(item) {
      var queue = [item];
      var result = [];

      while (queue.length > 0) {
        var _item$children;

        var _item = queue.pop();

        result.push(_item);

        if (((_item$children = _item.children) === null || _item$children === void 0 ? void 0 : _item$children.length) > 0) {
          queue = queue.concat(_item.children);
        }
      }

      return result;
    }
  }, {
    key: "collapseNode",
    value: function collapseNode(nodeId) {
      var collapseNodes = [];
      var collapseEdges = [];
      var targetNode = this.getNode(nodeId);
      targetNode.collapsed = true;
      targetNode.options.collapsed = true;

      if (!targetNode) {
        return;
      }

      var queue = [targetNode];

      while (queue.length > 0) {
        var node = queue.pop();
        collapseNodes.push(node);

        if (node.children && node.children.length > 0) {
          queue = queue.concat(node.children);
        }
      } // 先去掉target node做filter


      collapseNodes = collapseNodes.filter(function (item) {
        return item.id !== targetNode.id;
      });
      var tmp = {};
      collapseNodes.forEach(function (item) {
        tmp[item.id] = item;
        item.subCollapsed = true;
      });
      collapseEdges = this.edges.filter(function (item) {
        var _isCollapsed = false;

        if (item.type === 'endpoint') {
          _isCollapsed = !!tmp[item.sourceNode.id] || !!tmp[item.targetNode.id];
        } else {
          _isCollapsed = !!tmp[item.source.id] || !!tmp[item.target.id];
        }

        if (item.sourceNode.id === targetNode.id) {
          _isCollapsed = true;
        }

        if (_isCollapsed) {
          item.collapsed = true;
        }

        return _isCollapsed;
      });
      collapseNodes.unshift(targetNode);
      collapseNodes.forEach(function (item) {
        if (item.subCollapsed) {
          item.destroy(true);
        } // 重置子节点的collapsed状态


        if (item.id !== nodeId && item.collapsed) {
          delete item.collapsed;
        }
      });
      collapseEdges.forEach(function (item) {
        item.destroy(true);
      });
      this.redraw();
      return {
        nodes: collapseNodes,
        edges: collapseEdges
      };
    }
  }, {
    key: "expandNode",
    value: function expandNode(nodeId, nodes) {
      var targetNode = this.getNode(nodeId);
      var subNodes = [];
      var collapseEdges = [];
      var queue = [targetNode];

      while (queue.length > 0) {
        var node = queue.pop();
        subNodes.push(node);

        if (node.children && node.children.length > 0) {
          queue = queue.concat(node.children);
        }
      } // 先去掉target node做filter


      subNodes = subNodes.filter(function (item) {
        return item.id !== targetNode.id;
      });
      var tmp = {};
      subNodes.forEach(function (item) {
        tmp[item.id] = item;
        item.subCollapsed = true;
      });
      collapseEdges = this.edges.filter(function (item) {
        var _isCollapsed = false;

        if (item.type === 'endpoint') {
          _isCollapsed = !!tmp[item.sourceNode.id] || !!tmp[item.targetNode.id];
        } else {
          _isCollapsed = !!tmp[item.source.id] || !!tmp[item.target.id];
        }

        if (item.sourceNode.id === targetNode.id) {
          _isCollapsed = true;
        }

        return _isCollapsed;
      });
      this.nodes = _$d.differenceBy(this.nodes, subNodes, 'id');
      this.addNodes(subNodes, true);
      this.edges = _$d.filter(this.edges, function (a) {
        if (a.type === 'endpoint') {
          return !_$d.some(collapseEdges, function (b) {
            return a.sourceNode.id === b.sourceNode.id && a.targetNode.id === b.targetNode.id && a.source === b.source && a.target === b.target;
          });
        } else {
          return !_$d.some(collapseEdges, function (b) {
            return a.source === b.source && a.target === b.target;
          });
        }
      });
      this.addEdges(collapseEdges, true);
      subNodes.forEach(function (item) {
        delete item.subCollapsed;
      });
      delete targetNode.collapsed;
      collapseEdges.forEach(function (item) {
        delete item.collapsed;
      });
      this.redraw();
    }
  }, {
    key: "redraw",
    value: function redraw() {
      var rootNode = this.getRootNode();
      var tree = [];
      var tmpTreeObj = {};
      var queue = [rootNode];

      var _loop2 = function _loop2() {
        var node = queue.pop();
        var obj = {
          id: node.id
        };

        if (tmpTreeObj[node.id]) {
          obj = tmpTreeObj[node.id];
        } else {
          tmpTreeObj[obj.id] = obj;
        }

        if (node.isRoot) {
          obj['isRoot'] = node.isRoot;
        }

        if (node.collapsed) {
          obj['collapsed'] = node.collapsed;
        }

        tree.push(obj);

        if (node.children && node.children.length > 0) {
          obj.children = [];
          node.children.forEach(function (child) {
            var _childObj = {
              id: child.id
            };

            if (tmpTreeObj[child.id]) {
              _childObj = tmpTreeObj[child.id];
            } else {
              tmpTreeObj[child.id] = _childObj;
            }

            if (child.isRoot) {
              _childObj['isRoot'] = child.isRoot;
            }

            if (child.collapsed) {
              _childObj['collapsed'] = child.collapsed;
            }

            obj.children.push(_childObj);
          });
          queue = queue.concat(node.children);
        }
      };

      while (queue.length > 0) {
        _loop2();
      }

      var nodes = tree.filter(function (item) {
        return true;
      });

      this._autoLayout({
        nodes: nodes,
        edges: [],
        groups: []
      });

      this.nodes.forEach(function (item) {
        var _item$endpoints;

        if (item.subCollapsed) {
          return;
        }

        item === null || item === void 0 ? void 0 : (_item$endpoints = item.endpoints) === null || _item$endpoints === void 0 ? void 0 : _item$endpoints.forEach(function (endpoint) {
          endpoint.updatePos();
        });
        var obj = tmpTreeObj[item.id];

        if (item.top !== obj.top || item.left !== obj.left) {
          item.options.top = obj.top;
          item.options.left = obj.left;
          item.options.treePos = obj.treePos;
          item.moveTo(obj.left, obj.top);
        }
      });
      this.edges.forEach(function (item) {
        item.redraw();
      });
    }
  }, {
    key: "addNodes",
    value: function addNodes(data, isNotEventEmit) {
      var _this3 = this;

      var nodes = _get(_getPrototypeOf(TreeCanvas.prototype), "addNodes", this).call(this, data, isNotEventEmit);

      nodes.forEach(function (item) {
        if (item.parent) {
          var parentNode = _this3.getNode(item.parent);

          if (!_$d.some(parentNode.children, ['id', item.id])) {
            !parentNode.children && (parentNode.children = []);
            parentNode.children.push(item);
          }
        }
      });
      return nodes;
    }
  }, {
    key: "removeNodes",
    value: function removeNodes(data, isNotDelEdge, isNotEventEmit) {
      var _this4 = this;

      var nodes = data.map(function (item) {
        if (item instanceof Node) {
          return item;
        } else {
          return _this4.getNode(item);
        }
      });
      var rmNodes = [];
      nodes.forEach(function (item) {
        var _subTree = _this4.findSubTree(item);

        rmNodes = rmNodes.concat(_subTree); // 如果是某个节点的子节点,将此节点从父节点的children中移除

        if (item.parent) {
          var parentNode = _this4.getNode(item.parent);

          if (parentNode) {
            parentNode.children = parentNode.children.filter(function (node) {
              return node.id !== item.id;
            });
          }
        }
      });
      rmNodes = _$d.unionBy(rmNodes, 'id');

      var result = _get(_getPrototypeOf(TreeCanvas.prototype), "removeNodes", this).call(this, rmNodes, isNotDelEdge, isNotEventEmit);

      return result;
    }
  }, {
    key: "getRootNode",
    value: function getRootNode() {
      return this.nodes.filter(function (item) {
        return item.isRoot;
      })[0];
    }
  }, {
    key: "draw",
    value: function draw(opts, params, callback) {
      var _this5 = this;

      var nodes = this._handleTreeNodes(opts.nodes || [], _$d.get(params, 'isFlatNode', false)); // 需要过滤掉collapsed的


      _get(_getPrototypeOf(TreeCanvas.prototype), "draw", this).call(this, {
        nodes: nodes,
        edges: opts.edges,
        groups: opts.groups
      }, function () {
        var tmp = {};

        _this5.nodes.forEach(function (item) {
          tmp[item.id] = item;
          item.children = [];
        });

        _this5.nodes.forEach(function (item) {
          if (item.isRoot || !item.parent) {
            return;
          }

          var parentNode = tmp[item.parent];

          if (!parentNode) {
            return;
          }

          !parentNode.children && (parentNode.children = []);
          parentNode.children.unshift(item);
        });

        callback && callback({
          nodes: _this5.nodes,
          edges: _this5.edges,
          groups: _this5.groups
        });
      });
    } // getDataMap(isFlat) {
    // }

  }, {
    key: "_autoLayout",
    value: function _autoLayout(options) {
      var rootNode = options.nodes.filter(function (item) {
        return item.isRoot;
      })[0];

      if (!rootNode) {
        return;
      } // 这部分需要优化


      var type = _$d.get(this, 'layout.type', 'compactBox');

      if (Hierarchy$1[type]) {
        var NODE_SIZE = 16;
        var NODE_WIDTH = 30;
        var PEM = 5;
        Hierarchy$1[type](rootNode, _$d.assign({
          direction: 'H',
          getId: function getId(d) {
            return d.id;
          },
          getHeight: function getHeight(d) {
            if (d.isRoot) {
              return NODE_SIZE * 2;
            }

            return NODE_SIZE;
          },
          getWidth: function getWidth(d) {
            if (d.isRoot) {
              return NODE_WIDTH * 2;
            }

            return NODE_WIDTH;
          },
          getHGap: function getHGap(d) {
            return 100;
          },
          getVGap: function getVGap(d) {
            return 30;
          },
          getSubTreeSep: function getSubTreeSep(d) {
            if (!d.children || !d.children.length) {
              return 0;
            }

            return PEM;
          }
        }, _$d.get(this, 'layout.options', {})));
      }
    }
  }]);

  return TreeCanvas;
}(BaseCanvas);

var $$a = require('jquery');

var Default = {
  TEMPLATE: '<div class="butterfly-toolTip" role="butterfly-tooltip"><div class="butterfly-tooltip-arrow"></div><div class="butterfly-tooltip-inner"></div></div>',
  $viewAppend: 'body',
  $viewScale: '.butterfly-wrapper',
  // 有缩放的图层
  $viewCon: '.butterfly-toolTip',
  $inner: '.butterfly-tooltip-inner',
  callbackWhitelist: ['LI'],
  evntList: ['hover'],
  callBackOpen: true,
  delay: 300
};

var _toFixed_3 = function _toFixed_3(num) {
  if (!num) {
    return 0;
  }

  if (Number(num)) {
    return Number(parseFloat(num).toFixed(3));
  }
};

var _getTipOffset = function _getTipOffset(placement, pos) {
  var _pos = {};
  var left = pos.left,
      top = pos.top,
      width = pos.width,
      height = pos.height,
      actualWidth = pos.actualWidth,
      actualHeight = pos.actualHeight;
  left = _toFixed_3(left);
  top = _toFixed_3(top);
  width = _toFixed_3(width);
  height = _toFixed_3(height);
  actualWidth = _toFixed_3(actualWidth);
  actualHeight = _toFixed_3(actualHeight);

  switch (placement) {
    case 'top':
      _pos.left = left + width / 2 - actualWidth / 2;
      _pos.top = top - actualHeight;
      break;

    case 'left':
      _pos.left = left - actualWidth;
      _pos.top = top + height / 2 - actualHeight / 2;
      break;

    case 'right':
      _pos.left = left + width;
      _pos.top = top + height / 2 - actualHeight / 2;
      break;

    case 'bottom':
      _pos.left = left + width / 2 - actualWidth / 2;
      _pos.top = top + actualHeight;

    default:
      _pos.left = left + width / 2 - actualWidth / 2;
      _pos.top = top - actualHeight;
  }

  return _pos;
};

var show = function show(opts, dom, toolTipDom, callBackFunc, e) {
  $$a(opts.$viewCon).remove();
  opts.callBackOpen && toolTipDom.on('click', function (e) {
    if (callBackFunc) {
      var res = {
        key: $$a(e.target).attr("key"),
        value: e.target.textContent
      };

      if (opts.callbackWhitelist.includes(e.target.nodeName)) {
        $$a(opts.$viewCon).remove();
        callBackFunc(res, e);
      }
    }

    e.stopPropagation();
  });
  toolTipDom.appendTo($$a(opts.$viewAppend));
  var placement = opts.placement || 'top';
  toolTipDom.addClass(placement);
  var scaleArr = ($$a(opts.$viewScale).css("transform") || 'none').replace('matrix(', '').replace(')', '').split(',');
  var scale = scaleArr[0] === 'none' ? 1 : scaleArr[0];
  var pos = {
    top: dom.offset().top,
    left: dom.offset().left,
    width: dom.outerWidth() * scale,
    height: dom.outerHeight() * scale,
    actualWidth: toolTipDom.outerWidth(),
    actualHeight: toolTipDom.outerHeight()
  };
  var posInit = {};

  if (opts.x || opts.x === 0) {
    posInit = {
      left: opts.x,
      top: opts.y
    };
  } else {
    posInit = _getTipOffset(placement, pos);
  }

  var position = "top: ".concat(posInit.top, "px; left: ").concat(posInit.left, "px;");
  toolTipDom.attr('style', position).addClass('in');
};

var hide = function hide(toolTipDom) {
  toolTipDom.removeClass('in').remove();
};

function creatTips(option, dom, callBackFunc) {
  var opts = _objectSpread2(_objectSpread2({}, Default), option);

  var toolTipDom = $$a(opts.TEMPLATE);
  toolTipDom.find(opts.$inner).html(opts.content);
  var _timeoutMouseover = null;
  opts.evntList.includes('hover') && dom.on('mouseover', function (e) {
    clearTimeout(_timeoutMouseover);
    _timeoutMouseover = setTimeout(function () {
      show(opts, dom, toolTipDom, callBackFunc);
    }, opts.delay);
  }).on('mouseout', function (e) {
    clearTimeout(_timeoutMouseover);
    !$$a(opts.$viewCon).hasClass('butterfly-active-tip') && hide(toolTipDom);
  });

  var clickOrSame = function clickOrSame(e) {
    if ($$a(opts.$viewCon).hasClass('butterfly-active-tip')) {
      $$a(opts.$viewCon).removeClass('butterfly-active-tip');
      hide(toolTipDom);
    } else {
      toolTipDom.addClass('butterfly-active-tip');
      show(opts, dom, toolTipDom, callBackFunc);
    }
  };

  opts.evntList.includes('click') && dom.on('click', function (e) {
    clickOrSame();
  });
  opts.evntList.includes('mousedown') && dom.mousedown(function (e) {
    $$a(dom).bind("contextmenu", function (e) {
      return false;
    });

    if (3 == e.which) {
      clickOrSame();
    }
  });
  opts.nowShow && show(opts, dom, toolTipDom, callBackFunc);
  return dom;
}

function creatMenus(opts, dom, callBackFunc) {
  var menu = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  var showTip = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var menuDom = $$a('<div class="butterfly-tip-menu-div"></div>');
  var menuUl = $$a('<ul class="butterfly-tip-menu-ul"></ul>');
  (menu || []).forEach(function (item) {
    $$a('<li class="butterfly-tip-menu-li"></li>').attr('key', "".concat(item.key)).text(item.value).appendTo(menuUl);
  });
  showTip && $$a("<div class=\"butterfly-tip-menu-title\">".concat(opts.content, "</div>")).appendTo(menuDom);
  menuUl.appendTo(menuDom);
  opts.placement = opts.placement || 'right';
  opts.content = menuDom;
  opts.evntList = opts.evntList || [];
  opts.nowShow = opts.nowShow || true;
  return creatTips(opts, dom, callBackFunc);
}

var Tips = {
  creatTips: creatTips,
  creatMenus: creatMenus
};

var _$e = require('lodash');
module.exports = {
  Canvas: BaseCanvas,
  TreeCanvas: TreeCanvas,
  Edge: BaseEdge,
  Endpoint: BaseEndpoint,
  Group: BaseGroup,
  Node: BaseNode,
  TreeNode: TreeNode,
  Minimap: Minimap,
  Tips: Tips,
  Layout: Layout$1
};
//# sourceMappingURL=index.js.map
